/*
 * generated by Xtext 2.17.1
 */
package org.sodalite.dsl.ui.contentassist


import org.eclipse.emf.ecore.EObject
import org.eclipse.jface.text.contentassist.ICompletionProposal
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.eclipse.xtext.Keyword
import org.sodalite.dsl.kb_reasoner_client.types.ReasonerData
import java.util.List
import org.sodalite.dsl.kb_reasoner_client.types.Type
import org.sodalite.dsl.rM.RM_Model
import java.util.ArrayList
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.sodalite.dsl.rM.EPREFIX_TYPE
import org.sodalite.dsl.kb_reasoner_client.exceptions.NotRolePermissionException
import org.eclipse.swt.graphics.Image
import java.net.URL
import org.eclipse.core.runtime.FileLocator
import org.eclipse.jface.resource.ImageDescriptor
import org.osgi.framework.Bundle
import org.eclipse.core.runtime.Path
import java.util.Map
import java.util.HashMap
import org.eclipse.core.runtime.Platform
import org.sodalite.ide.ui.logger.SodaliteLogger
import org.sodalite.dsl.kb_reasoner_client.types.TemplateData
import org.sodalite.dsl.rM.EEvenFilter
import org.sodalite.dsl.kb_reasoner_client.types.RequirementDefinitionData
import org.sodalite.dsl.kb_reasoner_client.types.RequirementDefinition
import org.sodalite.dsl.rM.impl.GetPropertyBodyImpl
import org.sodalite.dsl.rM.EEntityReference
import org.sodalite.dsl.rM.ENodeType
import org.sodalite.dsl.rM.impl.GetAttributeBodyImpl
import org.sodalite.dsl.rM.EFunction
import org.sodalite.dsl.kb_reasoner_client.types.PropertyDefinitionData
import org.sodalite.dsl.kb_reasoner_client.types.AttributeDefinitionData
import org.sodalite.dsl.rM.GetAttributeBody
import org.sodalite.dsl.rM.GetPropertyBody
import org.sodalite.dsl.kb_reasoner_client.types.CapabilityDefinitionData
import org.sodalite.dsl.rM.EPropertyDefinition
import org.sodalite.dsl.rM.EAttributeDefinition
import org.sodalite.dsl.kb_reasoner_client.types.TypeData
import org.sodalite.dsl.rM.EInterfaceDefinitionBody
import org.sodalite.dsl.kb_reasoner_client.types.OperationDefinitionData
import org.sodalite.dsl.rM.EPolicyType
import org.sodalite.dsl.rM.EOperationDefinition
import org.sodalite.dsl.rM.EInterfaceType
import org.sodalite.dsl.kb_reasoner_client.exceptions.SodaliteException
import org.sodalite.dsl.ui.helper.BackendHelper
import org.sodalite.dsl.ui.helper.RMHelper
import org.eclipse.xtext.impl.KeywordImpl
import org.eclipse.xtext.EcoreUtil2
import org.sodalite.dsl.rM.EInterfaceDefinition
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.emf.common.util.URI
import org.eclipse.xtext.util.LineAndColumn

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */

class RMProposalProvider extends AbstractRMProposalProvider {	
	final String SELF_DESCRIPTION = 
	"A TOSCA orchestrator will interpret this keyword as the Node or Relationship\n" + 
	"Template instance that contains the function at the time the function is evaluated"
	final String SOURCE_DESCRIPTION = 
	"A TOSCA orchestrator will interpret this keyword as the Node Template instance that\n" + 
	"is at the source end of the relationship that contains the referencing function."
	final String TARGET_DESCRIPTION = 
	"A TOSCA orchestratorwill interpret this keyword as the Node Template instance that is\n" + 
	"at the target end of the relationship that contains the referencing function"
	final String HOST_DESCRIPTION = "A TOSCA orchestrator will interpret this keyword to refer\n" + 
	"to the all nodes that “host”the node using this reference (i.e., as identified by its HostedOn relationship)."
	
	var Map <String, Image> images = new HashMap<String, Image>();
	

	
//	def private void raiseConfigurationIssue(String message) throws Exception {
//		val Shell parent = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
//		MessageDialog.openError(parent, "Sodalite Preferences Error", message + " in Sodalite preferences pages");
//		throw new Exception(message + " in Sodalite preferences pages");
//	}
	
	
	// this override filters the keywords for which to create content assist proposals
	override void completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext,
		ICompletionProposalAcceptor acceptor) {
		_completeKeyword(keyword, contentAssistContext, acceptor);
	}
	
	override void completeRM_Model_Imports(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		try{
			System.out.println("Invoking content assist for imports")
			
			val ReasonerData<String> modules = BackendHelper.getKBReasoner().modules
				
			System.out.println ("Modules retrieved from KB: " + modules.elements)
			for (module: modules.elements){
				System.out.println ("\tModule: " + module)
				val proposalText = RMHelper.extractModule(module)
				val displayText = proposalText
				val additionalProposalInfo = null
				val Image image = getImage("icons/module2.png");
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
	
			super.completeRM_Model_Imports(model, assignment, context, acceptor)
			
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	}
	
	override void completeENodeType_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for ENodeType::name property")
		val String proposalText = "tosca.types.id"
		val String displayText = "tosca.types.id"
		val String additionalProposalInfo = "The required id of the node type"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
	override void completeEDataTypeBody_SuperType(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for EDataType::supertype property")
		try{
			//Get modules from model
			val List<String> importedModules = RMHelper.processListModules(model)
			val String module = RMHelper.getModule(model)
			
			val ReasonerData<Type> types = BackendHelper.getKBReasoner().getDataTypes(importedModules)
			System.out.println ("Data types retrieved from KB:")
			for (type: types.elements){
				System.out.println ("\tData type: " + type.label)
				val qtype = type.module !== null?RMHelper.getLastSegment(type.module, '/') + '/' + type.label:type.label
				val proposalText = qtype
				val displayText = qtype
				val additionalProposalInfo = type.description
				var Image image = getImage("icons/data_type.png")
				if (type.module !== null) 
					image = getImage("icons/primitive_data_type.png")
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
			
			//Add other data types defined locally in the model
			val rootModel = RMHelper.findModel(model) as RM_Model
			
			for (dataType: rootModel.dataTypes.dataTypes){
				val EPREFIX_TYPE ePrefixType = dataType.name as EPREFIX_TYPE
				System.out.println ("\tLocal node: " + ePrefixType.type)
				val proposalText = module !== null ?module + "/" + ePrefixType.type: ePrefixType.type
				val displayText = module !== null ?module + "/" + ePrefixType.type: ePrefixType.type
				val additionalProposalInfo = dataType.data.description
				var Image image = getImage("icons/data_type.png")
				if (module !== null) 
					image = getImage("icons/primitive_data_type.png")
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}		
	
			super.completeENodeTypeBody_SuperType(model, assignment, context, acceptor)
		}catch (NotRolePermissionException ex){
			RMHelper.showReadPermissionErrorDialog
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	}
	
	override void completeENodeTypeBody_SuperType(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for NodeType::superType property")
		try{
			//Get modules from model
			val List<String> importedModules = RMHelper.processListModules(model)
			val String module = RMHelper.getModule(model)
			
			val ReasonerData<Type> nodes = BackendHelper.getKBReasoner().getNodeTypes(importedModules)
			System.out.println ("Nodes retrieved from KB:")
			for (node: nodes.elements){
				System.out.println ("\tNode: " + node.label)
				val qnode = node.module !== null ?RMHelper.getLastSegment(node.module, '/') + '/' + node.label:node.label
				val proposalText = qnode
				val displayText = qnode
				val additionalProposalInfo = node.description
				var Image image = getImage("icons/type.png")
				if (node.module !== null) 
					image = getImage("icons/primitive_type.png")
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
			
			//Add other nodes defined locally in the model
			val rootModel = RMHelper.findModel(model) as RM_Model
			
			for (nodeType: rootModel.nodeTypes.nodeTypes){
				System.out.println ("\tLocal node: " + nodeType.name)
				val proposalText = module + "/" + nodeType.name 
				val displayText = module + "/" + nodeType.name 
				val additionalProposalInfo = nodeType.node.description
				var Image image = getImage("icons/type.png")
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
	
			super.completeENodeTypeBody_SuperType(model, assignment, context, acceptor)
		}catch (NotRolePermissionException ex){
			RMHelper.showReadPermissionErrorDialog
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	}
	
	override void completeEInterfaceTypeBody_SuperType(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for Interface Type::superType property")
		try{
			//Get modules from model
			val List<String> importedModules = RMHelper.processListModules(model)
			val String module = RMHelper.getModule(model)
			
			val ReasonerData<Type> types = BackendHelper.getKBReasoner().getInterfaceTypes(importedModules)
			System.out.println ("Types retrieved from KB:")
			for (type: types.elements){
				System.out.println ("\tInterface: " + type.label)
				val qnode = type.module !== null?RMHelper.getLastSegment(type.module, '/') + '/' + type.label:type.label
				val proposalText = qnode
				val displayText = qnode
				val additionalProposalInfo = type.description
				var Image image = getImage("icons/interface.png")
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
			
			//Add other interface types defined locally in the model
			val rootModel = RMHelper.findModel(model) as RM_Model
			
			for (interfaceType: rootModel.interfaceTypes.interfaceTypes){
				System.out.println ("\tLocal interface: " + interfaceType.name)
				val proposalText = module + "/" + interfaceType.name 
				val displayText = module + "/" + interfaceType.name 
				val additionalProposalInfo = interfaceType.interface.description
				var Image image = getImage("icons/interface.png")
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
	
			super.completeENodeTypeBody_SuperType(model, assignment, context, acceptor)
		}catch (NotRolePermissionException ex){
			RMHelper.showReadPermissionErrorDialog
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	}
	
	override void completeEPolicyTypeBody_SuperType(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for Policy Type::superType property")
		try{
			//Get modules from model
			val List<String> importedModules = RMHelper.processListModules(model)
			val String module = RMHelper.getModule(model)
			
			val ReasonerData<Type> types = BackendHelper.getKBReasoner().getPolicyTypes(importedModules)
			System.out.println ("Policies retrieved from KB:")
			for (type: types.elements){
				System.out.println ("\tPolicy: " + type.label)
				val qnode = type.module !== null?RMHelper.getLastSegment(type.module, '/') + '/' + type.label:type.label
				val proposalText = qnode
				val displayText = qnode
				val additionalProposalInfo = type.description
				var Image image = getImage("icons/policy_type.png")
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
			
			//Add other interface types defined locally in the model
			val rootModel = RMHelper.findModel(model) as RM_Model
			
			for (policyType: rootModel.policyTypes.policyTypes){
				System.out.println ("\tLocal policy: " + policyType.name)
				val proposalText = module + "/" + policyType.name 
				val displayText = module + "/" + policyType.name 
				val additionalProposalInfo = policyType.policy.description
				var Image image = getImage("icons/policy_type.png")
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
	
			super.completeENodeTypeBody_SuperType(model, assignment, context, acceptor)
		}catch (NotRolePermissionException ex){
			RMHelper.showReadPermissionErrorDialog
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	
	}
	
	override void completeERelationshipTypeBody_SuperType(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for RelationshipType::supertype property")
		try{
			//Get modules from model
			val List<String> importedModules = RMHelper.processListModules(model)
			val String module = RMHelper.getModule(model)
			
			val ReasonerData<Type> relationships = BackendHelper.getKBReasoner().getRelationshipTypes(importedModules)
			System.out.println ("Relationships retrieved from KB:")
			val Image image = getImage("icons/relationship.png")
			for (relationship: relationships.elements){
				System.out.println ("\tRelationship: " + relationship.label)
				val qrelationship = relationship.module !== null?RMHelper.getLastSegment(relationship.module, '/') + '/' + relationship.label:relationship.label
				val proposalText = qrelationship
				val displayText = qrelationship
				val additionalProposalInfo = relationship.description
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
			
			//Add other relationships defined locally in the model
			val rootModel = RMHelper.findModel(model) as RM_Model
			
			for (relationshipType: rootModel.relationshipTypes.relationshipTypes){
				System.out.println ("\tLocal relationship type: " + relationshipType.name)
				val proposalText = module + "/" + relationshipType.name 
				val displayText = module + "/" + relationshipType.name 
				val additionalProposalInfo = relationshipType.relationship.description
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
	
			super.completeENodeTypeBody_SuperType(model, assignment, context, acceptor)
		}catch (NotRolePermissionException ex){
			RMHelper.showReadPermissionErrorDialog
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	}
	
	override void completeECapabilityTypeBody_SuperType(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for CapabilityType::supertype property")
		try{
			//Get modules from model
			val List<String> importedModules = RMHelper.processListModules(model)
			val String module = RMHelper.getModule(model)
			
			
			val ReasonerData<Type> capabilitiess = BackendHelper.getKBReasoner().getCapabilityTypes(importedModules)
			System.out.println ("Capabilities retrieved from KB:")
			val Image image = getImage("icons/capability.png")
			for (cap: capabilitiess.elements){
				System.out.println ("\tCapability: " + cap.label)
				val qcap = cap.module !== null?RMHelper.getLastSegment(cap.module, '/') + '/' + cap.label:cap.label
				val proposalText = qcap
				val displayText = qcap
				val additionalProposalInfo = cap.description
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
			
			//Add other capabilities defined locally in the model
			val rootModel = RMHelper.findModel(model) as RM_Model
			
			for (cap: rootModel.capabilityTypes.capabilityTypes){
				System.out.println ("\tLocal capability type: " + cap.name)
				val proposalText = module + "/" + cap.name 
				val displayText = module + "/" + cap.name 
				val additionalProposalInfo = cap.capability.description
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
	
			super.completeENodeTypeBody_SuperType(model, assignment, context, acceptor)	
		}catch (NotRolePermissionException ex){
			RMHelper.showReadPermissionErrorDialog
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	}
	
	override void completeEInterfaceDefinitionBody_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for InterfaceDefinition::type property")
		try{
			//Get modules from model
			val List<String> importedModules = RMHelper.processListModules(model)
			val String module = RMHelper.getModule(model)
		
			
			val ReasonerData<Type> interfaces = BackendHelper.getKBReasoner().getInterfaceTypes(importedModules)
			System.out.println ("Interfaces retrieved from KB:")
			val Image image = getImage("icons/interface.png")
			for (interface: interfaces.elements){
				System.out.println ("\tCapability: " + interface.label)
				val qinterface = interface.module !== null?RMHelper.getLastSegment(interface.module, '/') + '/' + interface.label:interface.label
				val proposalText = qinterface
				val displayText = qinterface
				val additionalProposalInfo = interface.description
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
			
			//Add other interfaces defined locally in the model
			val rootModel = RMHelper.findModel(model) as RM_Model
			
			for (interface: rootModel.interfaceTypes.interfaceTypes){
				System.out.println ("\tLocal interface type: " + interface.name)
				val proposalText = module + "/" + interface.name 
				val displayText = module + "/" + interface.name 
				val additionalProposalInfo = interface.interface.description
				createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
			}
	
			super.completeENodeTypeBody_SuperType(model, assignment, context, acceptor)
		}catch (NotRolePermissionException ex){
			RMHelper.showReadPermissionErrorDialog
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	}
	
	override void completeEPropertyDefinitionBody_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeEDataTypeBody_SuperType(model, assignment, context, acceptor)
	}
	
	override void completeERequirementDefinitionBody_Capability(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeECapabilityTypeBody_SuperType(model, assignment, context, acceptor)
	}
	
	override void completeERequirementDefinitionBody_Node(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeENodeTypeBody_SuperType(model, assignment, context, acceptor)
	}
	
	override void completeERequirementDefinitionBody_Relationship(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeERelationshipTypeBody_SuperType(model, assignment, context, acceptor)
	}
	
	override void completeEAttributeDefinitionBody_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeEDataTypeBody_SuperType(model, assignment, context, acceptor)
	}
	
	override void completeEParameterDefinitionBody_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeEDataTypeBody_SuperType(model, assignment, context, acceptor)
	}
	
	override void completeGetAttributeBody_Req_cap(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for GetAttributeBody::req_cap property")
		completeGetAttributeOrPropertyFunction_Req_cap( model,  assignment,  context,  acceptor)
	}
	
	override void completeGetAttributeBody_Attribute(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for GetAttributeBody::attribute property")
		completeGetAttributeOrPropertyFunction_AttributeOrProperty( model, assignment, context, acceptor)
	}
	
	override void completeGetPropertyBody_Property(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for GetPropertyBody::property property")
		completeGetAttributeOrPropertyFunction_AttributeOrProperty( model, assignment, context, acceptor)
	}
	
	override void completeGetPropertyBody_Req_cap(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for GetPropertyBody::req_cap property")
		completeGetAttributeOrPropertyFunction_Req_cap( model,  assignment,  context,  acceptor)
	}
	
	override void completeEInterfaceDefinitionBody_Operations(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		try{
			val EInterfaceDefinitionBody interface = model as EInterfaceDefinitionBody
			val type = interface.type
			var interfaceId = (type.module !== null? type.module + '/':'') + type.type
			
			if (interfaceId !== null){
				val OperationDefinitionData operations = BackendHelper.getKBReasoner().getOperationsInInterface(interfaceId)
				if (operations !== null){
					val Image image = getImage("icons/operation.png")
					for (oper: operations.elements){
					 	val operation_label = RMHelper.getLastSegment(oper.uri.toString, '/')
						val proposalText = operation_label
						val displayText = operation_label
						val additionalProposalInfo = oper.getDescription!==null?"\nDescription: " + oper.getDescription:""
						createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);
					 }
				}
			}
		}catch(NotRolePermissionException ex){
			RMHelper.showReadPermissionErrorDialog
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	}
	
	override void completeEDataType_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for EDataType::name property")
		val String proposalText = "tosca.datatypes.id"
		val String displayText = "tosca.datatypes.id"
		val String additionalProposalInfo = "The required id of the data type"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
	override void completeEArtifactType_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for EArtifactType::name property")
		val String proposalText = "tosca.artifacts.id"
		val String displayText = "tosca.artifacts.id"
		val String additionalProposalInfo = "The required id of the artifact type"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
	override void completeECapabilityType_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for ECapabilityType::name property")
		val String proposalText = "tosca.capabilities.id"
		val String displayText = "tosca.capabilities.id"
		val String additionalProposalInfo = "The required id of the capability type"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
	override void completeEInterfaceType_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		System.out.println("Invoking content assist for EInterfaceType::name property")
		val String proposalText = "tosca.interfaces.id"
		val String displayText = "tosca.interfaces.id"
		val String additionalProposalInfo = "The required id of the interface type"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}

	
	override void completeERelationshipType_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		System.out.println("Invoking content assist for ERelationshipType::name property")
		val String proposalText = "tosca.relationships.id"
		val String displayText = "tosca.relationships.id"
		val String additionalProposalInfo = "The required id of the relationship type"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
	override void completeEPolicyType_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for EPolicyType::name property")
		val String proposalText = "tosca.policies.id"
		val String displayText = "tosca.policies.id"
		val String additionalProposalInfo = "The required id of the policy type"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
	override void completeEPropertyDefinition_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		System.out.println("Invoking content assist for EPropertyDefinition::name property")
		val String proposalText = "property_name"
		val String displayText = "property_name"
		val String additionalProposalInfo = "The required id of the property definition"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
	override void completeEAttributeDefinition_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		System.out.println("Invoking content assist for EAttributeDefinition::name property")
		val String proposalText = "attribute_name"
		val String displayText = "attribute_name"
		val String additionalProposalInfo = "The required id of the attribute definition"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
	override void completeEInterfaceDefinition_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for EInterfaceDefinition::name property")
		val String proposalText = "interface_name"
		val String displayText = "interface_name"
		val String additionalProposalInfo = "The required id of the interface definition"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
	override void completeEOperationDefinition_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for EOperationDefinition::name property")
		val String proposalText = "operation_name"
		val String displayText = "operation_name"
		val String additionalProposalInfo = "The required id of the operation definition"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
	override void completeEParameterDefinition_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for EParameterDefinition::name property")
		val String proposalText = "parameter_name"
		val String displayText = "parameter_name"
		val String additionalProposalInfo = "The required id of the parameter definition"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
	override void completeECapabilityDefinition_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for ECapabilityDefinition::name property")
		val String proposalText = "capability_name"
		val String displayText = "capability_name"
		val String additionalProposalInfo = "The required id of the capability definition"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
	override void completeECapabilityDefinitionBody_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeECapabilityTypeBody_SuperType(model, assignment, context, acceptor)
	}
	
	override void completeEValidSourceType_SourceTypes(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		completeENodeTypeBody_SuperType(model, assignment, context, acceptor)
	}
	
	
	override void completeERequirementDefinition_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for ERequirementDefinition::name property")
		val String proposalText = "requirement_name"
		val String displayText = "requirement_name"
		val String additionalProposalInfo = "The required id of the requirement definition"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
	override void completeEPropertyDefinitionBody_Required(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for EPropertyDefinitionBody::required property")
		createNonEditableCompletionProposal ("true", "true", null, context, "", acceptor);
		createNonEditableCompletionProposal ("false", "false", null, context, "", acceptor);
	}
	
	override void completeGetAttributeBody_Entity(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for GetAttributeBody::entity property")
		createEntityProposals (context, acceptor);
	}
	
	override void completeGetPropertyBody_Entity(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for GetPropertyBody::entity property")
		createEntityProposals (context, acceptor);
	}
	
	override void completeEMapEntry_Key(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for EMapEntry::key property")
		createEditableCompletionProposal ("map_key_name", "map_key_name", null, context, "Key name for map entry", acceptor);
	}
	
	override void completeELIST_List(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for ELIST::list property")
		createEditableCompletionProposal ("\"value\"", "\"value\"", null, context, "Give a single String value or a comma separate list of String values", acceptor);
	}
	
	override void complete_EMAP(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		System.out.println("Invoking content assist for EMAP::map property")
		createEditableCompletionProposal ("{", "{", null, context, "Start a Map of key=value entries", acceptor);
	}
	
	/*override void complete_EPrimary(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		var String workspaceDir = ResourcesPlugin.getWorkspace().getRoot().getLocation().toString().replaceAll("%20", " ")
		var URI project_uri =  context.document.resourceURI
		var String project_name = project_uri.segment(project_uri.segmentCount-2).replaceAll("%20", " ")
		val node = EcoreUtil2.getContainerOfType(model,ENodeType).name
		val interface = EcoreUtil2.getContainerOfType(model,EInterfaceDefinition).name
		val operation = EcoreUtil2.getContainerOfType(model,EOperationDefinition).name
		//var String proposal = "primary:"+"\""+workspaceDir+"/"+project_name+"/Ansible"+"/"+node+"/"+interface+"/"+operation+".yaml"+"\""
		var String proposal = "\""+"/Ansible"+"/"+node+"/"+interface+"/"+operation+".yaml"+"\""
		createNonEditableCompletionProposal(proposal,proposal,null,context,"Default path where the appropriate .yaml file is generated from .ans file",acceptor)
	}*/
	
	override void completeEPrimary_File(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		var String workspaceDir = ResourcesPlugin.getWorkspace().getRoot().getLocation().toString().replaceAll("%20", " ")
		var URI project_uri =  context.document.resourceURI
		var String intermediatePath = project_uri.toString.replaceAll("%20", " ").replace("platform:/resource", "")
		var String RMName = project_uri.segment(project_uri.segmentCount-1).replaceAll("%20", " ")
		intermediatePath = intermediatePath.replace(RMName,"")
		var document = context.document
		var offset = context.currentNode.offset
		
		val node = EcoreUtil2.getContainerOfType(model,ENodeType).name
		val interface = EcoreUtil2.getContainerOfType(model,EInterfaceDefinition).name
		val operation = EcoreUtil2.getContainerOfType(model,EOperationDefinition).name
		RMName = RMName.split("\\.").get(0)
		var String relativePath = RMName+"-Ansible files"+"/"+node+"/"+interface
		var String localPath = intermediatePath+relativePath
		var String absolutePath = workspaceDir+localPath
		// Show file selection dialog to the user. Get path of file selected by the user and provide suggestion
		var input = RMHelper.selectImplementationFile("Select implementation primary file",absolutePath,localPath,operation+".yaml") 
		//Relative path
		if(input.equals(localPath+"/"+operation+".yaml")){
			input = "\"" + "./" + relativePath+"/"+operation+".yaml" + "\"" +"\n"
			document.replace(offset,1,input)
			createEditableCompletionProposal (input, input, null, context, "", acceptor);
		}
		//No file has been selected
		else if(input.empty){
			return
		}
		//Absolute path
		else{
			input = "\"" + input + "\"" +"\n"
			document.replace(offset,1,input)
			createEditableCompletionProposal (input, input, null, context, "", acceptor);
		}
		
	}
	
	override void completeEPrimary_Relative_path(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		var String workspaceDir = ResourcesPlugin.getWorkspace().getRoot().getLocation().toString().replaceAll("%20", " ")
		var URI project_uri =  context.document.resourceURI
		var String intermediatePath = project_uri.toString.replaceAll("%20", " ").replace("platform:/resource", "")
		var String RMName = project_uri.segment(project_uri.segmentCount-1).replaceAll("%20", " ")
		intermediatePath = intermediatePath.replace(RMName,"")
		createEditableCompletionProposal ("\"" + workspaceDir + intermediatePath + "\"", "\"" + workspaceDir + intermediatePath + "\"", null, context, "The path where current resource model is located", acceptor);
	}
	
	override void completeEDependencies_Files(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		// Show file selection dialog to the user. Get path of file selected by the user and provide suggestion
		val input = "\"" + RMHelper.selectFile ("Select implementation dependency file") + "\""
		createEditableCompletionProposal (input, input, null, context, "", acceptor);
	}
	
	override void completeEEvenFilter_Node(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		try{
			val List<String> importedModules = RMHelper.processListModules(model)
			val ReasonerData<Type> types = BackendHelper.getKBReasoner().getNodeTypes(importedModules)
			val TemplateData templates = BackendHelper.getKBReasoner().getTemplates(importedModules)		
			createProposalsForTypeList(types, "icons/type.png", "icons/primitive_type.png", context, acceptor)
			createProposalsForTemplateList(templates, "icons/resource2.png", context, acceptor)
		}catch (NotRolePermissionException ex){
			RMHelper.showReadPermissionErrorDialog
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}	
	}
	
	override void completeEEvenFilter_Requirement(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		try{
			val EEvenFilter filter = model as EEvenFilter
			if (filter.node !== null){
				var String qnode = RMHelper.getNodeName (filter.node)
				val RequirementDefinitionData reqs = BackendHelper.getKBReasoner().getTypeRequirements(qnode)
				createProposalsForRequirementsList(reqs, "icons/requirement.png", context, acceptor)
			}
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	}
	
	override void completeETargetType_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		try{
			//Find local and KB node types
			val List<String> importedModules = RMHelper.processListModules(model)
			val TypeData typeData = BackendHelper.getKBReasoner().getNodeTypes(importedModules)
			val type_image = "icons/type.png";	
			val primitive_type_image = "icons/primitive_type.png";
			createProposalsForTypeList(typeData, type_image, primitive_type_image, context, acceptor)
			val List<ENodeType> localTypes = (RMHelper.findModel(model) as RM_Model).nodeTypes.nodeTypes
			createProposalsForTypeList(localTypes, type_image, primitive_type_image, context, acceptor)
		}catch (NotRolePermissionException ex){
			RMHelper.showReadPermissionErrorDialog
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	}
	
	override void completeECallOperationActivityDefinitionBody_Operation(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		try{
			//Find local and KB node types
			val List<String> importedModules = RMHelper.processListModules(model)
			val OperationDefinitionData operationsData = BackendHelper.getKBReasoner().getOperations(importedModules)
			val type_image = "icons/operation.png";	
			createProposalsForOperationData(operationsData, type_image, null, context, acceptor)
			val List<EOperationDefinition> localOperations = RMHelper.findLocalOperations(model)
			createProposalsForOperationList(localOperations, type_image, null, context, acceptor)
		}catch (NotRolePermissionException ex){
			RMHelper.showReadPermissionErrorDialog
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	}
	
	override void completeETriggerDefinition_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val String proposalText = "trigger_name"
		val String displayText = "trigger_name"
		val String additionalProposalInfo = "The required name for trigger definition"

		createEditableCompletionProposal(proposalText, displayText, null, context, additionalProposalInfo, acceptor);
	}
	
//	def List<EOperationDefinition> findLocalOperations(EObject object){
//		var List<EOperationDefinition> operations = new ArrayList<EOperationDefinition>()
//		val RM_Model model = (RMHelper.findModel(object) as RM_Model)
//		for (interface: model.interfaceTypes.interfaceTypes){
//			for (op:interface.interface.operations.operations){
//				operations.add(op)
//			}
//		}
//		return operations
//	}
	
//	def String getNodeName (EPREFIX_REF nodeRef){
//		var String qnode = null
//		if (nodeRef instanceof EPREFIX_TYPE){
//			val EPREFIX_TYPE node = nodeRef as EPREFIX_TYPE
//			qnode = node.module !== null? node.module + '/' + node.type: node.type
//		}else if (nodeRef instanceof EPREFIX_ID){
//			val EPREFIX_ID node = nodeRef as EPREFIX_ID
//			qnode = node.module !== null? node.module + '/' + node.id: node.id
//		}
//		return qnode
//	}
	
	
	def void createProposalsForTypeList(ReasonerData<Type> types, String defaultImage, String primitiveImage,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		for (type: types.elements){
			val qtype = type.module !== null ?RMHelper.getLastSegment(type.module, '/') + '/' + type.label:type.label
			val proposalText = qtype
			val displayText = qtype
			val additionalProposalInfo = type.description
			var Image image = getImage(defaultImage)
			if (type.module !== null) 
				image = getImage(primitiveImage)
			createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
		}
	}
	
	def void createProposalsForTypeList(TypeData types, String defaultImage, String primitiveImage,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		for (type: types.elements){
			val qtype = type.module !== null?RMHelper.getLastSegment(type.module, '/') + '/' + type.label:type.label
			val proposalText = qtype
			val displayText = qtype
			val additionalProposalInfo = type.description
			var Image image = getImage(defaultImage)
			if (type.module !== null) 
				image = getImage(primitiveImage)
			createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
		}
	}
	
	def void createProposalsForOperationData(OperationDefinitionData operations, String defaultImage, String primitiveImage,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		for (operation: operations.elements){
			val module = RMHelper.getBetweenLast2Delimiters(operation.definedIn, '/')
			val _interface = RMHelper.getLastSegment(operation.definedIn, '/')
			val oper_name = RMHelper.getLastSegment(operation.uri.toString, '/')
			val qOperation = module !== 'tosca'?
				module + '/' + _interface + '.' + oper_name:_interface + '.' + oper_name
			val proposalText = qOperation
			val displayText = qOperation
			val additionalProposalInfo = operation.description
			var Image image = getImage(defaultImage)
			createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
		}
	}
	
	def void createProposalsForOperationList(List<EOperationDefinition> operations, String defaultImage, String primitiveImage,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		for (operation: operations){
			val _interface = operation.eContainer.eContainer.eContainer as EInterfaceType
			val module = RMHelper.getModule(operation)
			val qOperation = module!==null? 
				module + '/' + _interface.name + '.' + operation.name:
				_interface.name + '.' + operation.name
			val proposalText = qOperation
			val displayText = qOperation
			val additionalProposalInfo = operation.operation.description
			var Image image = getImage(defaultImage)
			createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
		}
	}
	
	def void createProposalsForTypeList(List<ENodeType> types, String defaultImage, String primitiveImage,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		for (type: types){
			val module = RMHelper.getModule(type)
			val qtype = module !== null?RMHelper.getLastSegment(module, '/') + '/' + type.name:type.name
			val proposalText = qtype
			val displayText = qtype
			val additionalProposalInfo = type.node.description
			var Image image = getImage(defaultImage)
			if (module !== null) 
				image = getImage(primitiveImage)
			createNonEditableCompletionProposal(proposalText, displayText, image, context, additionalProposalInfo, acceptor);	
		}
	}
	
	def void createProposalsForTemplateList(TemplateData templates, String defaultImage,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		for (template: templates.elements){
			val qtype = template.module !== null?RMHelper.getLastSegment(template.module, '/') + '/' + template.label:template.label
			val proposalText = qtype
			val displayText = qtype
			var Image image = getImage(defaultImage)
			createNonEditableCompletionProposal(proposalText, displayText, image, context, null, acceptor);	
		}
	}
	
	def void createProposalsForRequirementsList(RequirementDefinitionData reqs, String defaultImage,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		for (req: reqs.elements){
			createProposalForRequirement (req, defaultImage, context, acceptor)
		}
	}
	
	def createProposalForRequirement(RequirementDefinition req, String defaultImage,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		var property_label = req.uri.toString.substring(req.uri.toString.lastIndexOf('/') + 1, req.uri.toString.length)
		var proposalText = property_label
		var displayText = property_label
		var additionalProposalInfo = ""
		if (req.getCapability !== null)
			additionalProposalInfo += "\nCapability: " + req.getCapability.getLabel
		if (req.getNode !== null)
			additionalProposalInfo += "\nNode: " + req.getNode.getLabel
		if (req.getOccurrences !== null)
			additionalProposalInfo += "\nOccurrences: [" + req.getOccurrences.min + ", " + req.getOccurrences.max + "]"	
		var Image image = getImage(defaultImage)
		createNonEditableCompletionProposal(proposalText, displayText, image, context, null, acceptor);	
	}
	
//	def List<String> processListModules(EObject model){
//		//Get modules from model
//		val List<String> importedModules = RMHelper.getImportedModules(model)
//		val String module = RMHelper.getModule(model)
//		//Add current module to imported ones for searching in the KB
//		if (module !== null)
//			importedModules.add(module)
//		return importedModules
//	}
	
	def void _completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext,
		ICompletionProposalAcceptor acceptor) {
		val ICompletionProposal proposal = createCompletionProposal(keyword.getValue(),
			getKeywordDisplayString(keyword), getImage(keyword), contentAssistContext);
		proposal.additionalProposalInfo = getAdditionalProposalInfo(keyword)
		getPriorityHelper().adjustKeywordPriority(proposal, contentAssistContext.getPrefix());
		acceptor.accept(proposal);
	}
	
	def String getAdditionalProposalInfo(Keyword keyword) {
		if (keyword instanceof KeywordImpl) {
			val keywordImpl = keyword as KeywordImpl
			val rule = RMHelper.findParserRule (keywordImpl)
			
			//RM_Model
			if (rule.name == "RM_Model" && keyword.value == "module:")
				return "The namespace where model entity names will be declared"
			else if (rule.name == "RM_Model" && keyword.value == "import:")
				return "Imports another namespace declared within the bound KB 
						to retrieve its model entity definitions"
			else if (rule.name == "RM_Model" && keyword.value == "artifact_types:")
				return "This section contains an optional map of artifact type definitions 
						for use in the service template"
			else if (rule.name == "RM_Model" && keyword.value == "data_types:")
				return "Declares a map of optional TOSCA Data Type definitions."
			else if (rule.name == "RM_Model" && keyword.value == "capability_types:")
				return "This section contains an optional map of capability type definitions 
						for use in the service template"
			else if (rule.name == "RM_Model" && keyword.value == "interface_types:")
				return "This section contains an optional map of interface type definitions 
						for use in the service template."
			else if (rule.name == "RM_Model" && keyword.value == "relationship_types:")
				return "This section contains a map of relationship type definitions 
						for use in the service template."
			else if (rule.name == "RM_Model" && keyword.value == "node_types:")
				return "TThis section contains a mapof node type definitions 
						for use in the service template."
			else if (rule.name == "RM_Model" && keyword.value == "policy_types:")
				return "This section contains a list of policy type definitions 
						for use in the service template."
			
			//ENodeTypeBody
			else if (rule.name == "ENodeTypeBody" && keyword.value == "derived_from:")
				return "Represents the required symbolic name of the Node Type being declared"
			else if (rule.name == "ENodeTypeBody" && keyword.value == "attributes:")
				return "An optional map of attribute definitions for the Node Type."
			else if (rule.name == "ENodeTypeBody" && keyword.value == "properties:")
				return "An optional map of property definitions for the Node Type."
			else if (rule.name == "ENodeTypeBody" && keyword.value == "requirements:")
				return "An optional list of requirement definitions for the Node Type."
			else if (rule.name == "ENodeTypeBody" && keyword.value == "capabilities:")
				return "An optional map of capability definitions for the Node Type."
			else if (rule.name == "ENodeTypeBody" && keyword.value == "interfaces:")
				return "An optional map of interface definitions supported by the Node Type"
			else if (rule.name == "ENodeTypeBody" && keyword.value == "description:")
				return "Represents the optional description string for the corresponding node_type_name."
				
			//EPropertyDefinitionBody
			else if (rule.name == "EPropertyDefinitionBody" && keyword.value == "type:")
				return "The required data type for the property."
			else if (rule.name == "EPropertyDefinitionBody" && keyword.value == "description:")
				return "The optional description for the property."
			else if (rule.name == "EPropertyDefinitionBody" && keyword.value == "required:")
				return "An optional key that declares a property as required (true) or not (false)."
			else if (rule.name == "EPropertyDefinitionBody" && keyword.value == "status:")
				return "The optional status of the property relative to the specification or implementation.\nSee table below for valid values: 
						supported: Indicates the property is supported.  This is the default value for all property definitions.
						unsupported: Indicates the property is not supported.
						experimental: Indicates the property is experimental and has no official standing.
						deprecated: Indicates the property has been deprecated by a new specification version."
			else if (rule.name == "EPropertyDefinitionBody" && keyword.value == "constraints:")
				return "The optional list of sequenced constraint clauses for the property"
			else if (rule.name == "EPropertyDefinitionBody" && keyword.value == "entry_schema:")
				return "The optional schema definition for the entries in properties of TOSCA set types such as list or map."
			else if (rule.name == "EPropertyDefinitionBody" && keyword.value == "default:")
				return "An optional key that may provide a value to be used as a default if not provided by another means"
				
			//EAttributeDefinitionBody
			else if (rule.name == "EAttributeDefinitionBody" && keyword.value == "type:")
				return "The required data type for the attribute."
			else if (rule.name == "EAttributeDefinitionBody" && keyword.value == "description:")
				return "The optional description for the attribute."
			else if (rule.name == "EAttributeDefinitionBody" && keyword.value == "required:")
				return "An optional key that declares a property as required (true) or not (false)."
			else if (rule.name == "EAttributeDefinitionBody" && keyword.value == "status:")
				return "The optional status of the attribute relative to the specification or implementation.\nSee table below for valid values: 
						supported: Indicates the property is supported.  This is the default value for all property definitions.
						unsupported: Indicates the property is not supported.
						experimental: Indicates the property is experimental and has no official standing.
						deprecated: Indicates the property has been deprecated by a new specification version."
			else if (rule.name == "EAttributeDefinitionBody" && keyword.value == "entry_schema:")
				return "The optional schema definition for the entries in attributes of TOSCA set types such as list or map."
			else if (rule.name == "EAttributeDefinitionBody" && keyword.value == "default:")
				return "An optional key that may provide a value to be used as a default if not provided by another means. \nThis value SHALL be type compatible with the type declared by the property definition’s type keyname"
						
			//ERequirementDefinitionBody
			else if (rule.name == "ERequirementDefinitionBody" && keyword.value == "capability:")
				return "The required reserved keyname used that can be used to provide \nthe name of a valid Capability Type that can fulfill the requirement"
			else if (rule.name == "ERequirementDefinitionBody" && keyword.value == "node:")
				return "The optional reserved keyname used to provide the name of a valid \nNode Type that contains the capability definition that can be used \nto fulfill the requirement. "
			else if (rule.name == "ERequirementDefinitionBody" && keyword.value == "relationship:")
				return "The optional reserved keyname used to provide the name of \na valid Relationship Type to construct when fulfilling the requirement"
			else if (rule.name == "ERequirementDefinitionBody" && keyword.value == "occurrences:")
				return "The optional minimum and maximum occurrences for the requirement. \nNote: the keyword UNBOUNDEDis also supported to represent any positive integer."
			
			//ECapabilityDefinitionBody
			else if (rule.name == "ECapabilityDefinitionBody" && keyword.value == "type:")
				return "The required name of the Capability Type the capability definition is based upon"
			else if (rule.name == "ECapabilityDefinitionBody" && keyword.value == "description:")
				return "The optional description of the Capability definition."
			else if (rule.name == "ECapabilityDefinitionBody" && keyword.value == "attributes:")
				return "An optional map of attribute definitions for the Capability definition"
			else if (rule.name == "ECapabilityDefinitionBody" && keyword.value == "properties:")
				return "An optional map of property definitions for the Capability definition."
			else if (rule.name == "ECapabilityDefinitionBody" && keyword.value == "occurrences:")
				return "The optional minimum and maximum occurrences for the capability. \nBy default, an exported Capability should allow at least one relationship \nto be formed with it with a maximum of UNBOUNDED relationships.\nNote: the keyword UNBOUNDEDis also supported to represent any positive integer."
			else if (rule.name == "ECapabilityDefinitionBody" && keyword.value == "valid_source_types:")
				return "An optional list of one or more valid names of Node Types that are supported \nas valid sources of any relationship established to the declared Capability Type."
			
				
			//EInterfaceDefinitionBody
			else if (rule.name == "EInterfaceDefinitionBody" && keyword.value == "type:")
				return "Represents the required symbolic name of the interface as a string"
			else if (rule.name == "EInterfaceDefinitionBody" && keyword.value == "inputs:")
				return "The optional map of input property definitions available to all defined operations\n for interface definitions that are within TOSCA Node or Relationship Type definitions. \nThis includes when interface definitions are included as part of a\n Requirement definition in a Node Type."
			else if (rule.name == "EInterfaceDefinitionBody" && keyword.value == "operations:")
				return "The optional map of operations defined for this interface."	
				
				
			//EOperationDefinitionBody
			else if (rule.name == "EOperationDefinitionBody" && keyword.value == "description:")
				return "The optional description string for the associated named operation"
			else if (rule.name == "EOperationDefinitionBody" && keyword.value == "implementation:")
				return "The optional definition of the operation implementation"
			else if (rule.name == "EOperationDefinitionBody" && keyword.value == "inputs:")
				return "The optional map of input properties definitions (i.e., parameter definitions)\n for operation definitions that are within TOSCA Node or Relationship Type definitions.\n This includes when operation definitions are included as part of a Requirement definition in a Node Type"
			
			//EPrimary
			else if (rule.name == "EPrimary" && keyword.value == "primary:")
				return "The optional implementation artifact (i.e., the primary script file within a TOSCA CSAR file). "
			else if (rule.name == "EPrimary" && keyword.value == "relative_path:")
				return "The relative path in user's filesystem where artifact is located"
				
			//EDependencies
			else if (rule.name == "EDependencies" && keyword.value == "dependencies:")
				return "The optional list of one or more dependent or secondary implementation artifacts\n which are referenced by the primary implementation artifact\n (e.g., a library the script installs or a secondary script)."
			else if (rule.name == "EDependencies" && keyword.value == "relative_path:")
				return "The relative path in user's filesystem where artifact is located"
			
			//EParameterDefinitionBody
			else if (rule.name == "EParameterDefinitionBody" && keyword.value == "type:")
				return "The required data type for the parameter."
			else if (rule.name == "EParameterDefinitionBody" && keyword.value == "description:")
				return "Represents the optional description of the parameter."
			else if (rule.name == "EParameterDefinitionBody" && keyword.value == "default:")
				return "Contains a type-compatible value that may be used as a default 
						if not provided by another means."
			else if (rule.name == "EParameterDefinitionBody" && keyword.value == "value:")
				return "The type-compatible value to assign to the named parameter. 
					Parameter values may be provided as the result from the 
					evaluation of an expression or a function."
					
			//EPolicyTypeBody
			else if (rule.name == "EPolicyTypeBody" && keyword.value == "derived_from:")
				return "Represents the name (string) of the Policy Type this Policy Type definition\n derives from (i.e., its“parent” type)"
			else if (rule.name == "EPolicyTypeBody" && keyword.value == "description:")
				return "Represents the optional description string for the corresponding policy_type_name."
			else if (rule.name == "EPolicyTypeBody" && keyword.value == "properties:")
				return "An optional mapof property definitions for the Policy Type"
			else if (rule.name == "EPolicyTypeBody" && keyword.value == "targets:")
				return "An optional list of valid Node Types or Group Types the Policy Type can be applied to.\nNote: This can be viewed by TOSCA Orchestrators as an implied relationship to the target nodes,\n but one that does not have operational lifecycle considerations.\n For example, if we were to name this as an explicit Relationship Type we might call this “AppliesTo” (node or group)."
			else if (rule.name == "EPolicyTypeBody" && keyword.value == "triggers:")
				return "An optional mapof policy triggers for the Policy Type."
		
			
			//ETriggerDefinitionBody
			else if (rule.name == "ETriggerDefinitionBody" && keyword.value == "description:")
				return "The optional description string for the named trigger."
			else if (rule.name == "ETriggerDefinitionBody" && keyword.value == "event:")
				return "The required name of the event that activates the trigger’s action.\n A deprecated form of this keyname is “event_type”"
			else if (rule.name == "ETriggerDefinitionBody" && keyword.value == "schedule:")
				return "The optional time interval during which the trigger is valid\n (i.e., during which the declared actions will be processed)."
			else if (rule.name == "ETriggerDefinitionBody" && keyword.value == "target_filter:")
				return "The optional filter used to locate the attribute to monitor for the trigger’s defined condition.\n This filter helps locate the TOSCA entity (i.e., node or relationship) \nor further a specific capability of that entity that contains the attribute to monitor"
			else if (rule.name == "ETriggerDefinitionBody" && keyword.value == "condition:")
				return "The optional condition which contains a condition clause definition\n specifying one or multiple attribute constraint that can be monitored.\n Note: this is optional since sometimes the event occurrence itself  is enough to trigger the action"
			else if (rule.name == "ETriggerDefinitionBody" && keyword.value == "action:")
				return "The list of sequential activities to be performed when the event is triggered\n and the condition is met (i.e.evaluates to true)"
			
			
			//EEvenFilter
			else if (rule.name == "EEvenFilter" && keyword.value == "node:")
				return "The required name of the node type or template that contains\n either the attribute to be monitored or contains the requirement that\n references the node that contains the attribute to be monitored"
			else if (rule.name == "EEvenFilter" && keyword.value == "requirement:")
				return "The optional name of the requirement within the filter’s node\n that can be used to locate a referenced node that contains an attribute to monitor."
			else if (rule.name == "EEvenFilter" && keyword.value == "capability:")
				return "The optional name of a capability within the filter’s node\n or within the node referenced by its requirement that contains the attribute to monitor."
			
			//ETimeInterval
			else if (rule.name == "ETimeInterval" && keyword.value == "start_time:")
				return "The inclusive start time for the time interval"
			else if (rule.name == "ETimeInterval" && keyword.value == "end_time:")
				return "The inclusive end time for the time interval"
			
			//EExtendedTriggerCondition
			else if (rule.name == "EExtendedTriggerCondition" && keyword.value == "constraint:")
				return "The optional condition which contains a condition clause definition specifying\n one or multiple attribute constraint that can be monitored.\n Note: this is optional since sometimes the event occurrence itself is enough to trigger the action."
			else if (rule.name == "EExtendedTriggerCondition" && keyword.value == "period:")
				return "The optional period to use to evaluate for the condition."
			else if (rule.name == "EExtendedTriggerCondition" && keyword.value == "evaluations:")
				return "The optional number of evaluations that must be performed over the period\n to assert the condition exists."
			else if (rule.name == "EExtendedTriggerCondition" && keyword.value == "method:")
				return "The optional statistical method name to use to perform the evaluation of the condition."
			
			//ECallOperationActivityDefinitionBody
			else if (rule.name == "ECallOperationActivityDefinitionBody" && keyword.value == "operation:")
				return "The name of the operation to call, using the <interface_name>.<operation_name> notation.\n Required in the extended  notation."
			else if (rule.name == "ECallOperationActivityDefinitionBody" && keyword.value == "inputs:")
				return "The optional map of input parameter assignments for the called operation.\n Any provided input assignments will override the operation input assignment\n in the target node template for this operation call"
			
			//GetPropertyBody
			else if (rule.name == "GetPropertyBody" && keyword.value == "property:")
				return "The name of the property definition the function will return the value from"
			else if (rule.name == "GetPropertyBody" && keyword.value == "entity:")
				return "The required name of a modelable entity (e.g., Node Template or Relationship Template name)\n as declared in the service template that contains the named property definition\n the function will return the value from"
			else if (rule.name == "GetPropertyBody" && keyword.value == "req_cap:")
				return "The optional name of the requirement or capability name within the modelable entity\n (i.e., the <modelable_entity_name> which contains the named property definition the function will return the value from.\n Note:  If the property definition is located in the modelable entity directly,\n then this parameter MAY be omitted"
				
			//GetAttributeBody
			else if (rule.name == "GetAttributeBody" && keyword.value == "attribute:")
				return "The name of the attribute definition the function will return the value from"
			else if (rule.name == "GetAttributeBody" && keyword.value == "entity:")
				return "The required name of a modelable entity (e.g., Node Template or Relationship Template name)\n as declared in the service template that contains the named attribute definition\n the function will return the value from"
			else if (rule.name == "GetAttributeBody" && keyword.value == "req_cap:")
				return "The optional name of the requirement or capability name within the modelable entity\n (i.e., the <modelable_entity_name> which contains the named attribute definition the function will return the value from.\n Note:  If the attribute definition is located in the modelable entity directly,\n then this parameter MAY be omitted"
						
			else
				return ""
		}		
	}
	
	def setAdditionalProposalInfo(ICompletionProposal proposal, String info) {
		if (proposal instanceof ConfigurableCompletionProposal) {
			val ConfigurableCompletionProposal configurable = proposal as ConfigurableCompletionProposal;
			configurable.setAdditionalProposalInfo(info);
		}
	}
	
	def getImage(String path){
		if (!images.containsKey(path)){
			val Bundle bundle = Platform.getBundle("org.sodalite.ide.ui");
			val URL fullPathString = FileLocator.find(bundle, new Path(path), null)
			val ImageDescriptor imageDesc = ImageDescriptor.createFromURL(fullPathString)
			val Image image = imageDesc.createImage()
			if (image !== null)
				images.put(path, image)
		}
		return images.get(path)
	}
	
//	def extractModule(String module) {
//		return module.substring(module.lastIndexOf("/", module.length - 2) + 1, module.length - 1)
//	}
//	
//	def getBetweenLast2Delimiters(String input, String delimiter) {
//		val endIndex = input.lastIndexOf(delimiter)
//		val subInput = input.substring(0, endIndex)
//		val beginIndex = subInput.lastIndexOf(delimiter)
//		return input.subSequence(beginIndex + 1, endIndex)
//	}
//	
//	def getLastSegment(String string, String delimiter) {
//		var newString = string
//		if (string.endsWith(delimiter))
//			newString = string.substring(0, string.length - delimiter.length)
//		return newString.substring(newString.lastIndexOf(delimiter) + 1)
//	}
//	
//	def getModule(EObject object) {
//		val RM_Model model = findModel(object) as RM_Model
//		return model.module
//	}
//	
//	def getImportedModules(EObject object) {
//		val List<String> modules = new ArrayList()
//		val RM_Model model = findModel(object) as RM_Model
//		for (import: model.imports)
//			modules.add(import)
//		
//		return modules
//	}
//	
//	def findModel(EObject object) {
//		if (object.eContainer == null)
//			return null
//		else if (object.eContainer instanceof RM_Model)
//			return object.eContainer
//		else
//			return findModel(object.eContainer)
//	}
	
//	protected def String selectFile (String dialogText){
//		var shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
//		// File standard dialog
//		var fileDialog = new FileDialog(shell);
//		fileDialog.setText(dialogText);
//		//fileDialog.setFilterExtensions(new String[] { "*.txt" });
//		// Put in a readable name for the filter
//		//fileDialog.setFilterNames(new String[] { "Textfiles(*.txt)" });
//		var selected = fileDialog.open();
//		System.out.println(dialogText +": " + selected);
//		return "\"" + selected + "\""
//	}
	
	protected def void createEntityProposals(ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		val Image image = getImage("icons/resource2.png")
		createNonEditableCompletionProposal ("SELF", "SELF", image, context, SELF_DESCRIPTION, acceptor);
		createNonEditableCompletionProposal ("SOURCE", "SOURCE", image, context, SOURCE_DESCRIPTION, acceptor);
		createNonEditableCompletionProposal ("TARGET", "TARGET", image, context, TARGET_DESCRIPTION, acceptor);
		createNonEditableCompletionProposal ("HOST", "HOST", image, context, HOST_DESCRIPTION, acceptor);
	}

	protected def void createNonEditableCompletionProposal(String proposalText, String displayText, Image image,
		ContentAssistContext context, String additionalProposalInfo, ICompletionProposalAcceptor acceptor) {
		var ICompletionProposal proposal = createCompletionProposal(proposalText, displayText, image, context);
		if (proposal instanceof ConfigurableCompletionProposal) {
			val ConfigurableCompletionProposal configurable = proposal as ConfigurableCompletionProposal;
			configurable.setAdditionalProposalInfo(additionalProposalInfo);
			configurable.setAutoInsertable(false);
		}
		acceptor.accept(proposal)
	}
	
	protected def void createEditableCompletionProposal(String proposalText, String displayText, Image image,
		ContentAssistContext context, String additionalProposalInfo, ICompletionProposalAcceptor acceptor) {
		var ICompletionProposal proposal = createCompletionProposal(proposalText, displayText, image, context);
		if (proposal instanceof ConfigurableCompletionProposal) {
			val ConfigurableCompletionProposal configurable = proposal as ConfigurableCompletionProposal;
			configurable.setSelectionStart(configurable.getReplacementOffset());
			configurable.setSelectionLength(proposalText.length());
			configurable.setAutoInsertable(false);
			configurable.setSimpleLinkedMode(context.getViewer(), '\t', ' ');
			configurable.setAdditionalProposalInfo(additionalProposalInfo);
		}
		acceptor.accept(proposal)
	}
	
//	protected def showReadPermissionErrorDialog(){
//		val Shell parent = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
//		MessageDialog.openError(parent, "Role Permissions error", 
//			"Your account does not have permissions to read some declared imports or module. \nPlease, check and fix them")
//	}
//	
//	protected def getEntityType (EFunction function){
//		var EEntityReference eEntityReference = null
//		if (function instanceof GetProperty)
//			eEntityReference = (function as GetProperty).property.entity
//		else if (function instanceof GetAttribute)
//			eEntityReference = (function as GetAttribute).attribute.entity
//			
//		if (eEntityReference === null)
//			return null
//			
//		var EObject node = null
//		if (eEntityReference instanceof EEntity){
//			val EEntity eEntity = eEntityReference as EEntity
//			if (eEntity.entity.equals('SELF')){
//				node = getType(function) as EObject
//			}
//		} else {
//			//TODO Support other entities: TARGET, HOST, SOURCE, concrete entity
//		}
//		return node
//	}
//	
//	def getNodeType(EObject object) {
//		if (object.eContainer === null)
//			return null
//		else if (object.eContainer instanceof ENodeType)
//			return object.eContainer
//		else
//			return getNodeType(object.eContainer)
//	}
//	
//	def getType(EObject object) {
//		if (object.eContainer === null)
//			return null
//		else if (object.eContainer instanceof ENodeType)
//			return object.eContainer
//		else if (object.eContainer instanceof EPolicyType)
//			return object.eContainer
//		else
//			return getType(object.eContainer)
//	}
//	
//	def findRequirementNodeInLocalType(String requirement, ENodeType nodeType) {
//		val RM_Model model = RMHelper.findModel(nodeType) as RM_Model
//		var ENodeType node = null
//		var module1 = model.module
//		if (module1 === null)
//			module1 = ""
//		if (nodeType.node.requirements === null)
//			return node
//		for (req: nodeType.node.requirements.requirements){
//			var module2 = req.requirement.node.module
//			if (module2 === null)
//				module2 = ""
//			if (req.name.equals(requirement)){
//				if (module1.equals(module2)){
//					node = findNodeType(model, req.requirement.node.type)						
//				}
//			}
//		}
//		return node
//	}
//	
//	def findRequirementInLocalType(String requirement, ENodeType nodeType) {
//		if (nodeType.node.requirements!==null){
//			for (req: nodeType.node.requirements.requirements){
//				if (req.name.equals(requirement)){
//					return req
//				}
//			}
//		}
//		return null
//	}
//	
//	def findCapabilityInLocalType(String capabilityName, ENodeType nodeType) {
//		var ECapabilityDefinition capability = null
//		if (nodeType.node.capabilities === null)
//			return capability
//		for (cap: nodeType.node.capabilities.capabilities){
//			if (cap.name.equals(capabilityName))
//				capability = cap
//		}
//		return capability
//	}
//	
//	def findNodeType(RM_Model model, String nodeName) {
//		for (node: model.nodeTypes.nodeTypes){
//			if (node.name.equals(nodeName))
//				return node
//		}
//		return null
//	}
	
	def proposeAttributesForEntity(RM_Model model, String resourceId, List<String> proposals){
		val nodeRef = resourceId.substring(resourceId.indexOf(":") + 1)
		if (resourceId.startsWith("local:")){
			val nodeName = RMHelper.getLastSegment(nodeRef, "/")
			proposeAttributesForEntityInLocal (model, nodeName, proposals)
		}else if (resourceId.startsWith("kb:")){
			proposeAttributesForEntityInKB (nodeRef, proposals)
		}
	}
	
	def proposeAttributesForEntityInKB(String resourceId, List<String> proposals){
		try{
			val AttributeDefinitionData attributeData = BackendHelper.getKBReasoner().getTypeAttributes(resourceId)
			for (attr:attributeData.elements){
				val prefix = "https://www.sodalite.eu/ontologies/workspace/1/"
				var attr_owner = resourceId
				if (attr.definedIn !== null)
					attr_owner = attr.definedIn.substring(prefix.length)
				val proposal = attr_owner + '.' + RMHelper.getLastSegment(attr.uri.toString, '/')
				proposals.add(proposal)
			}
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	}
	
	def proposeAttributesForEntityInLocal(RM_Model model, String resourceId, List<String> proposals){
		val ENodeType node = RMHelper.findNodeType(model, resourceId)
		val module = RMHelper.getModule(model)
		if (node !== null)
			for (attr:node.node.attributes.attributes){
				val proposal = module !== null? 
					module + "/" + node.name + "." + attr.name: node.name + "." + attr.name
				proposals.add(proposal)
			}
		//Get Attributes for superclass in KB
		val superclass = RMHelper.getReference(node.node.superType)
		proposeAttributesForEntityInKB(superclass, proposals)
	}
	
	def proposePropertiesForEntity(RM_Model model, String resourceId, List<String> proposals){
		val nodeRef = resourceId.substring(resourceId.indexOf(":") + 1)
		if (resourceId.startsWith("local:")){
			val nodeName = RMHelper.getLastSegment(nodeRef, "/")
			proposePropertiesForEntityInLocal (model, nodeName, proposals)
		}else if (resourceId.startsWith("kb:")){
			proposePropertiesForEntityInKB (nodeRef, proposals)
		}
	}
	
	def proposePropertiesForEntityInKB(String resourceId, List<String> proposals){
		try{
			//FIXME: obtain all properties for types subclasses of given resourceId
			val PropertyDefinitionData propertyData = BackendHelper.getKBReasoner().getTypeProperties(resourceId)
			for (prop:propertyData.elements){
				val prefix = "https://www.sodalite.eu/ontologies/workspace/1/"
				var prop_owner = resourceId
				if (prop.definedIn !== null)
					prop_owner = prop.definedIn.substring(prefix.length)
				val proposal = prop_owner + '.' + RMHelper.getLastSegment(prop.uri.toString, '/')
				proposals.add(proposal)
			}	
		}catch(SodaliteException ex){
			SodaliteLogger.log(ex.message, ex);
		}
	}	
	
	def proposePropertiesForEntityInLocal(RM_Model model, String resourceId, List<String> proposals){
		val ENodeType node = RMHelper.findNodeType(model, resourceId)
		val module = RMHelper.getModule(model)
		if (node !== null)
			for (prop:node.node.properties.properties){
				val proposal = module !== null? module + "/" + prop.name: prop.name
				proposals.add(proposal)
			}
		//TODO: Get Properties for superclass in KB
		
	}
	
	
	def suggestRequirementsOrCapabilitiesInNode(String module, ENodeType node, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		//Find requirements and capability assignments defined within the entity
		if (node.node.requirements !== null){
			val Image image = getImage("icons/requirement.png")
			for (req: node.node.requirements.requirements){
				val String proposal = module + '/' + node.name + '.' + req.name
				createEditableCompletionProposal(proposal, proposal, image, context, null, acceptor);
			}
		}
		if (node.node.capabilities !== null){
			val Image image = getImage("icons/capability.png")
			for (cap: node.node.capabilities.capabilities){
				val String proposal = module + '/' + node.name + '.' + cap.name
				createEditableCompletionProposal(proposal, proposal, image, context, null, acceptor);
			}
		}
		
		//Find requirements and capability assignments defined within the entity superClass
		//If superClass defined in local model
		var ENodeType superNode = null
		if (module.equals(node.node.superType.module)){
			val RM_Model model = RMHelper.findModel(node as EObject) as RM_Model
			superNode = RMHelper.findNodeType(model, node.node.superType.type)
			if (superNode !== null)
				suggestRequirementsOrCapabilitiesInNode(module, superNode, context, acceptor)
		}
		//If superClass defined in KB
		if (superNode === null){
			val superType = node.node.superType.module !== null?
				node.node.superType.module + '/' + node.node.superType.type:
				node.node.superType.type
			val RequirementDefinitionData reqData = BackendHelper.getKBReasoner().getTypeRequirements(superType)
			var Image image = getImage("icons/requirement.png")
			for (req: reqData.elements){
				val String proposal = superType + '.' + RMHelper.getLastSegment(req.uri.toString, '/')
				createEditableCompletionProposal(proposal, proposal, image, context, null, acceptor);
			}
			
			val CapabilityDefinitionData capData = BackendHelper.getKBReasoner().getTypeCapabilities(superType)
			image = getImage("icons/capability.png")
			for (cap: capData.elements){
				val String proposal = superType + '.' + RMHelper.getLastSegment(cap.uri.toString, '/')
				createEditableCompletionProposal(proposal, proposal, image, context, null, acceptor);
			}
		}
	}
	
	def proposeProperties (List<EPropertyDefinition> properties, List<String> proposals, String nodeName,  String module){
		for (prop:properties){
			val proposal = module!==null? 
				module + '/' + nodeName + "." + prop.name: 
				nodeName + "." + prop.name
			proposals.add(proposal)
		}
	}
	
	def proposeAttributes (List<EAttributeDefinition> attributes, List<String> proposals, String nodeName,  String module){
		for (prop:attributes){
			val proposal = module!==null? 
				module + '/' + nodeName + "." + prop.name: 
				nodeName + "." + prop.name
			proposals.add(proposal)
		}
	}
	
//	def getRequirementByNameInLocalNode (ENodeType node, String req_name){
//		if (node.node.requirements !== null){
//			for (ERequirementDefinition req: node.node.requirements.requirements){
//				if (req.name.equals(req_name))
//					return req		
//			}
//		}
//		return null
//	}
	
	def completeGetAttributeOrPropertyFunction_AttributeOrProperty(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		//TODO This method only supports SELF Entity. 
		// Refactor it for future support of other ENTITIES
		// Check getEntityType method
		var List<String> proposals = new ArrayList<String>()
		val String module = RMHelper.getModule(model)
		val RM_Model rm_model = RMHelper.findModel(model) as RM_Model
		//Get entity in this GetProperty body. If null, return
		var EObject node = null
		var EPREFIX_TYPE req_cap = null
		if (model instanceof GetPropertyBodyImpl){
			var body = model as GetPropertyBodyImpl
			node = RMHelper.getEntityType(body.eContainer as EFunction)
			req_cap = body.req_cap
		}else if (model instanceof GetAttributeBodyImpl){
			var body = model as GetAttributeBodyImpl
			node = RMHelper.getEntityType(body.eContainer as EFunction)
			req_cap = body.req_cap
		}
		if (node === null){
			return
		}
		if (node instanceof ENodeType && req_cap !== null){ //TODO support the case a capability is given
			val req_cap_name = RMHelper.getLastSegment(req_cap.type, '.')
			val nodeType = (node as ENodeType)
			val String targetNodeRef = RMHelper.findRequirementTargetNode(nodeType, req_cap_name)
			if (targetNodeRef !== null){
				// Find properties/attributes in target node, create suggestions
				if (model instanceof GetPropertyBodyImpl)
					proposePropertiesForEntity (rm_model, targetNodeRef, proposals)
				else if (model instanceof GetAttributeBodyImpl)
					proposeAttributesForEntity (rm_model, targetNodeRef, proposals)
			}
		} else {
			//Get the properties defined within the entity
			var List<EPropertyDefinition> properties = null
			var List<EAttributeDefinition> attributes = null
			var String node_name = null
			if (node instanceof ENodeType){
				val nodeType = (node as ENodeType)
				if (nodeType.node.properties!==null)
					properties = nodeType.node.properties.properties
				if (nodeType.node.attributes!==null)
					attributes = nodeType.node.attributes.attributes
				node_name = nodeType.name
			} else if (node instanceof EPolicyType){
				val policyType = (node as EPolicyType)
				properties = policyType.policy.properties.properties
				node_name = policyType.name
			}
			if (model instanceof GetPropertyBodyImpl)
				for (prop:properties){
					proposals.add(module + '/' + node_name + "." + prop.name)
				}
			else if (model instanceof GetAttributeBodyImpl)
				for (attr:attributes){
					proposals.add(module + '/' + node_name + "." + attr.name)
				}
		}
		
		//Create proposals for each found property. Prefix property with req|cap name when applies
		var Image image = null
		if (model instanceof GetPropertyBodyImpl)
			image = getImage("icons/property.png")
		else if (model instanceof GetAttributeBodyImpl)
			image = getImage("icons/attribute.png")
		for (proposal: proposals){
			createEditableCompletionProposal(proposal, proposal, image, context, null, acceptor);
		}
	}
	
//	def String findRequirementTargetNode (ENodeType node, String req_name){
//		// Find requirement in local node
//		var String nodeRef = null
//		val RM_Model model = RMHelper.findModel(node) as RM_Model
//		val ERequirementDefinition req = RMHelper.findRequirementInLocalType(req_name, node)
//		if (req !== null){
//			val EPREFIX_TYPE req_node = req.requirement.node
//			if (req_node !== null){
//				// Find requirement target node in local model, or
//				if (model.module.equals(req_node.module)){
//					val ENodeType target_node = RMHelper.findNodeType(model, req_node.type)
//					if (target_node !== null)
//						nodeRef = "local:" + RMHelper.getReference(target_node)
//				}
//				if (nodeRef === null){
//					// Find requirement target node in KB
//					nodeRef = "kb:" + RMHelper.findNodeByNameInKB(req_node)
//				}
//			}
//		}else{
//			// Find requirement in KB for node superclass, find node in KB
//			nodeRef = "kb:" + RMHelper.findRequirementNodeByNameInKB(RMHelper.getReference(node.node.superType), req_name)
//		}
//		return nodeRef
//	}
	
//	def getReference (ENodeType node){
//		RMHelper.getModule(node) !== null?RMHelper.getModule(node) + '/' + node.name:node.name
//	}
//	
//	def getReference (EPREFIX_TYPE node){
//		node.module !== null?node.module + '/' + node.type:node.type
//	}
//	
//	def getReference (EPREFIX_REF node){
//		if (node instanceof EPREFIX_TYPE){
//			node.module !== null?node.module + '/' + node.type:node.type
//		} else if (node instanceof EPREFIX_ID){
//			node.module !== null?node.module + '/' + node.id:node.id
//		}
//	}
//	
//	def findRequirementNodeByNameInKB(String type, String reqName){
//		val RequirementDefinitionData reqData = BackendHelper.getKBReasoner().getTypeRequirements(type)
//		for (req: reqData.elements){
//			val name = req.uri.toString.substring(req.uri.toString.lastIndexOf('/') + 1)
//			if (name.equals(reqName))
//				return req.node.module !== null?
//					req.node.module + '/' + req.node.label:req.node.label
//		}
//		return null
//	}
//	
//	def findNodeByNameInKB(EPREFIX_TYPE node){
//		//Get modules from model
//		val List<String> importedModules = RMHelper.getImportedModules(node)
//		val String module = RMHelper.getModule(node)
//
//		//Add current module to imported ones for searching in the KB
//		importedModules.add(module)
//		val TypeData typeData = BackendHelper.getKBReasoner().getNodeTypes(importedModules)
//		for (type: typeData.elements){
//			val name = type.uri.toString.substring(type.uri.toString.lastIndexOf('/') + 1)
//			if (name.equals(node.type)){
//				var String type_module = null
//				if (type.module !== null){
//					type_module = type.module.substring (type.module.lastIndexOf("/", type.module.length - 2) + 1, type.module.length - 1)
//				}
//				return type_module !== null?
//					type_module + '/' + type.label:type.label	
//			}
//		}
//		return null
//	}
	
	def completeGetAttributeOrPropertyFunction_Req_cap(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val String module = RMHelper.getModule(model)
		//Get entity in this GetProperty body. If null, return
		val ENodeType node = RMHelper.getEntityType(model.eContainer as EFunction) as ENodeType
		
		if (node === null){
			return
		}
		
		//Find requirements and capability assignments defined within the entity
		var EEntityReference entityRef = null
		if (model instanceof GetPropertyBodyImpl){
			val GetPropertyBody body = model as GetPropertyBody
			entityRef = body.entity
		}else if (model instanceof GetAttributeBodyImpl){
			val GetAttributeBody body = model as GetAttributeBody
			entityRef = body.entity
		}
		
		suggestRequirementsOrCapabilitiesInNode (module, node, context, acceptor)
	}
	
	def String getProjectName(URI project_uri){
		var project = project_uri.toString
		project = project.replace("platform:/resource", "")
		var p = project.split("/")
		var projectName = project.split("/").get(1).replaceAll("%20", " ")
		return projectName
	}
	
//	def findCapabilitiesInNodeType (String nodeRef){
//		val CapabilityDefinitionData capabilities = BackendHelper.getKBReasoner().getTypeCapabilities(nodeRef)
//		return capabilities.elements
//	}
//	
//	def getRequirementNameFromRequirementRef (EPREFIX_REF reqRef){
//		var String reqName = null
//		if (reqRef instanceof EPREFIX_TYPE){
//			val EPREFIX_TYPE req = reqRef as EPREFIX_TYPE
//			reqName = RMHelper.getLastSegment(req.type, '.')
//		}else if (reqRef instanceof EPREFIX_ID){
//			val EPREFIX_ID req = reqRef as EPREFIX_ID
//			reqName = RMHelper.getLastSegment(req.id, '.')
//		}
//		return reqName
//	}
//	
//	def getNodeFromRequirementRef (EPREFIX_REF reqRef){
//		var String nodeRef = null
//		if (reqRef instanceof EPREFIX_TYPE){
//			val EPREFIX_TYPE req = reqRef as EPREFIX_TYPE
//			val nodeName = req.type.substring (0, req.type.lastIndexOf('.'))
//			nodeRef = req.module !== null? req.module + '/' + nodeName: nodeName
//		}else if (reqRef instanceof EPREFIX_ID){
//			val EPREFIX_ID req = reqRef as EPREFIX_ID
//			val nodeName = req.id.substring (0, req.id.lastIndexOf('.'))
//			nodeRef = req.module !== null? req.module + '/' + nodeName: nodeName
//		}
//		return nodeRef
//	}
//	
//	def getId(EPREFIX_REF ref) {
//		if (ref instanceof EPREFIX_TYPE){
//			(ref as EPREFIX_TYPE).type
//		}else if (ref instanceof EPREFIX_ID){
//			(ref as EPREFIX_ID).id
//		}
//	}
//	
//	static enum Boolean{
//		True, False
//	}

}
