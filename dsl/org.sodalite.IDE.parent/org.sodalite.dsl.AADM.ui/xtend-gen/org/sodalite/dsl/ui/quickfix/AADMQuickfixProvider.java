/**
 * generated by Xtext 2.17.1
 */
package org.sodalite.dsl.ui.quickfix;

import java.text.MessageFormat;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.ui.editor.model.edit.IModificationContext;
import org.eclipse.xtext.ui.editor.model.edit.ISemanticModification;
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider;
import org.eclipse.xtext.ui.editor.quickfix.Fix;
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor;
import org.eclipse.xtext.validation.Issue;
import org.sodalite.dsl.aADM.AADMFactory;
import org.sodalite.dsl.aADM.ENodeTemplate;
import org.sodalite.dsl.aADM.ENodeTemplateBody;
import org.sodalite.dsl.aADM.ERequirementAssignment;
import org.sodalite.dsl.aADM.ERequirementAssignments;
import org.sodalite.dsl.aADM.impl.ENodeTemplatesImpl;
import org.sodalite.dsl.ui.validation.ValidationIssue;

/**
 * Custom quickfixes.
 * 
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#quick-fixes
 */
@SuppressWarnings("all")
public class AADMQuickfixProvider extends DefaultQuickfixProvider {
  @Fix(ValidationIssue.REQUIREMENT)
  public void fixRequirement(final Issue issue, final IssueResolutionAcceptor acceptor) {
    String[] _data = issue.getData();
    final String data = ((String[]) _data)[0];
    final String targetRequirement = this.getSubstring(data, "requirements\\/(.*?)\\/");
    final String[] matches = this.getSubstring(data, "\\[(.*?)\\]").split(Pattern.quote(","));
    for (final String match : matches) {
      {
        int _lastIndexOf = match.lastIndexOf("/");
        int _plus = (_lastIndexOf + 1);
        final String targetNode = match.substring(_plus);
        final String message = MessageFormat.format("Create requirement \"{0}\" referencing node \"{1}\"", targetRequirement, targetNode);
        final String sub_message = message;
        final ISemanticModification _function = (EObject nodeTemplate, IModificationContext context) -> {
          ERequirementAssignment req = null;
          ENodeTemplate node = ((ENodeTemplate) nodeTemplate);
          ERequirementAssignments _requirements = node.getNode().getRequirements();
          boolean _tripleEquals = (_requirements == null);
          if (_tripleEquals) {
            final ERequirementAssignments requirements = AADMFactory.eINSTANCE.createERequirementAssignments();
            ENodeTemplateBody _node = node.getNode();
            _node.setRequirements(requirements);
          }
          EList<ERequirementAssignment> _requirements_1 = node.getNode().getRequirements().getRequirements();
          for (final ERequirementAssignment requirement : _requirements_1) {
            boolean _equalsIgnoreCase = requirement.getName().equalsIgnoreCase(targetRequirement);
            if (_equalsIgnoreCase) {
              req = requirement;
            }
          }
          if ((req == null)) {
            req = AADMFactory.eINSTANCE.createERequirementAssignment();
            req.setName(targetRequirement);
            node.getNode().getRequirements().getRequirements().add(req);
          }
          EObject _eContainer = nodeTemplate.eContainer();
          final ENodeTemplatesImpl model = ((ENodeTemplatesImpl) _eContainer);
          System.out.println(("Applying targetNode: " + targetNode));
          req.setNode(targetNode);
        };
        acceptor.accept(issue, message, sub_message, "", _function);
      }
    }
  }
  
  public ENodeTemplate getNode(final ENodeTemplatesImpl templates, final String name) {
    ENodeTemplate node = null;
    EList<ENodeTemplate> _nodeTemplates = templates.getNodeTemplates();
    for (final ENodeTemplate n : _nodeTemplates) {
      boolean _equals = n.getName().equals(name);
      if (_equals) {
        node = n;
      }
    }
    return node;
  }
  
  public String getSubstring(final String data, final String sPattern) {
    final Pattern pattern = Pattern.compile(sPattern);
    final Matcher matcher = pattern.matcher(data);
    boolean _find = matcher.find();
    if (_find) {
      return matcher.group(1);
    }
    return null;
  }
}
