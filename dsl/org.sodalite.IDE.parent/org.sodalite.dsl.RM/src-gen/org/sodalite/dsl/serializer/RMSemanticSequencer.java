/*
 * generated by Xtext 2.17.1
 */
package org.sodalite.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.sodalite.dsl.rM.EArtifactType;
import org.sodalite.dsl.rM.EArtifactTypeBody;
import org.sodalite.dsl.rM.EArtifactTypes;
import org.sodalite.dsl.rM.EAttributeDefinition;
import org.sodalite.dsl.rM.EAttributeDefinitionBody;
import org.sodalite.dsl.rM.EAttributes;
import org.sodalite.dsl.rM.ECapabilities;
import org.sodalite.dsl.rM.ECapabilityDefinition;
import org.sodalite.dsl.rM.ECapabilityDefinitionBody;
import org.sodalite.dsl.rM.ECapabilityType;
import org.sodalite.dsl.rM.ECapabilityTypeBody;
import org.sodalite.dsl.rM.ECapabilityTypeRef;
import org.sodalite.dsl.rM.ECapabilityTypes;
import org.sodalite.dsl.rM.EConstraints;
import org.sodalite.dsl.rM.EDataType;
import org.sodalite.dsl.rM.EDataTypeBody;
import org.sodalite.dsl.rM.EDataTypes;
import org.sodalite.dsl.rM.EDependencies;
import org.sodalite.dsl.rM.EEqual;
import org.sodalite.dsl.rM.EGreaterOrEqual;
import org.sodalite.dsl.rM.EGreaterThan;
import org.sodalite.dsl.rM.EImplementation;
import org.sodalite.dsl.rM.EInRange;
import org.sodalite.dsl.rM.EInputs;
import org.sodalite.dsl.rM.EInterfaceDefinition;
import org.sodalite.dsl.rM.EInterfaceDefinitionBody;
import org.sodalite.dsl.rM.EInterfaceType;
import org.sodalite.dsl.rM.EInterfaceTypeBody;
import org.sodalite.dsl.rM.EInterfaceTypes;
import org.sodalite.dsl.rM.EInterfaces;
import org.sodalite.dsl.rM.ELIST;
import org.sodalite.dsl.rM.ELength;
import org.sodalite.dsl.rM.ELessOrEqual;
import org.sodalite.dsl.rM.ELessThan;
import org.sodalite.dsl.rM.EMAP;
import org.sodalite.dsl.rM.EMapEntry;
import org.sodalite.dsl.rM.EMaxLength;
import org.sodalite.dsl.rM.EMinLength;
import org.sodalite.dsl.rM.ENodeType;
import org.sodalite.dsl.rM.ENodeTypeBody;
import org.sodalite.dsl.rM.ENodeTypeRef;
import org.sodalite.dsl.rM.ENodeTypes;
import org.sodalite.dsl.rM.EOperationDefinition;
import org.sodalite.dsl.rM.EOperationDefinitionBody;
import org.sodalite.dsl.rM.EOperations;
import org.sodalite.dsl.rM.EParameterDefinition;
import org.sodalite.dsl.rM.EParameterDefinitionBody;
import org.sodalite.dsl.rM.EPolicyType;
import org.sodalite.dsl.rM.EPolicyTypeBody;
import org.sodalite.dsl.rM.EPolicyTypes;
import org.sodalite.dsl.rM.EProperties;
import org.sodalite.dsl.rM.EPropertyDefinition;
import org.sodalite.dsl.rM.EPropertyDefinitionBody;
import org.sodalite.dsl.rM.ERelationshipType;
import org.sodalite.dsl.rM.ERelationshipTypeBody;
import org.sodalite.dsl.rM.ERelationshipTypes;
import org.sodalite.dsl.rM.ERequirementDefinition;
import org.sodalite.dsl.rM.ERequirementDefinitionBody;
import org.sodalite.dsl.rM.ERequirements;
import org.sodalite.dsl.rM.ESTRING;
import org.sodalite.dsl.rM.EValidSourceType;
import org.sodalite.dsl.rM.EValidTargetTypes;
import org.sodalite.dsl.rM.EValid_Values;
import org.sodalite.dsl.rM.GetAttribute;
import org.sodalite.dsl.rM.GetAttributeBody;
import org.sodalite.dsl.rM.GetInput;
import org.sodalite.dsl.rM.GetProperty;
import org.sodalite.dsl.rM.GetPropertyBody;
import org.sodalite.dsl.rM.RMPackage;
import org.sodalite.dsl.rM.RM_Model;
import org.sodalite.dsl.services.RMGrammarAccess;

@SuppressWarnings("all")
public class RMSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RMGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RMPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RMPackage.EARTIFACT_TYPE:
				sequence_EArtifactType(context, (EArtifactType) semanticObject); 
				return; 
			case RMPackage.EARTIFACT_TYPE_BODY:
				sequence_EArtifactTypeBody(context, (EArtifactTypeBody) semanticObject); 
				return; 
			case RMPackage.EARTIFACT_TYPES:
				sequence_EArtifactTypes(context, (EArtifactTypes) semanticObject); 
				return; 
			case RMPackage.EATTRIBUTE_DEFINITION:
				sequence_EAttributeDefinition(context, (EAttributeDefinition) semanticObject); 
				return; 
			case RMPackage.EATTRIBUTE_DEFINITION_BODY:
				sequence_EAttributeDefinitionBody(context, (EAttributeDefinitionBody) semanticObject); 
				return; 
			case RMPackage.EATTRIBUTES:
				sequence_EAttributes(context, (EAttributes) semanticObject); 
				return; 
			case RMPackage.ECAPABILITIES:
				sequence_ECapabilities(context, (ECapabilities) semanticObject); 
				return; 
			case RMPackage.ECAPABILITY_DEFINITION:
				sequence_ECapabilityDefinition(context, (ECapabilityDefinition) semanticObject); 
				return; 
			case RMPackage.ECAPABILITY_DEFINITION_BODY:
				sequence_ECapabilityDefinitionBody(context, (ECapabilityDefinitionBody) semanticObject); 
				return; 
			case RMPackage.ECAPABILITY_TYPE:
				sequence_ECapabilityType(context, (ECapabilityType) semanticObject); 
				return; 
			case RMPackage.ECAPABILITY_TYPE_BODY:
				sequence_ECapabilityTypeBody(context, (ECapabilityTypeBody) semanticObject); 
				return; 
			case RMPackage.ECAPABILITY_TYPE_REF:
				sequence_ECapabilityTypeRef(context, (ECapabilityTypeRef) semanticObject); 
				return; 
			case RMPackage.ECAPABILITY_TYPES:
				sequence_ECapabilityTypes(context, (ECapabilityTypes) semanticObject); 
				return; 
			case RMPackage.ECONSTRAINTS:
				sequence_EConstraints(context, (EConstraints) semanticObject); 
				return; 
			case RMPackage.EDATA_TYPE:
				sequence_EDataType(context, (EDataType) semanticObject); 
				return; 
			case RMPackage.EDATA_TYPE_BODY:
				sequence_EDataTypeBody(context, (EDataTypeBody) semanticObject); 
				return; 
			case RMPackage.EDATA_TYPES:
				sequence_EDataTypes(context, (EDataTypes) semanticObject); 
				return; 
			case RMPackage.EDEPENDENCIES:
				sequence_EDependencies(context, (EDependencies) semanticObject); 
				return; 
			case RMPackage.EEQUAL:
				sequence_EEqual(context, (EEqual) semanticObject); 
				return; 
			case RMPackage.EGREATER_OR_EQUAL:
				sequence_EGreaterOrEqual(context, (EGreaterOrEqual) semanticObject); 
				return; 
			case RMPackage.EGREATER_THAN:
				sequence_EGreaterThan(context, (EGreaterThan) semanticObject); 
				return; 
			case RMPackage.EIMPLEMENTATION:
				sequence_EImplementation(context, (EImplementation) semanticObject); 
				return; 
			case RMPackage.EIN_RANGE:
				sequence_EInRange(context, (EInRange) semanticObject); 
				return; 
			case RMPackage.EINPUTS:
				sequence_EInputs(context, (EInputs) semanticObject); 
				return; 
			case RMPackage.EINTERFACE_DEFINITION:
				sequence_EInterfaceDefinition(context, (EInterfaceDefinition) semanticObject); 
				return; 
			case RMPackage.EINTERFACE_DEFINITION_BODY:
				sequence_EInterfaceDefinitionBody(context, (EInterfaceDefinitionBody) semanticObject); 
				return; 
			case RMPackage.EINTERFACE_TYPE:
				sequence_EInterfaceType(context, (EInterfaceType) semanticObject); 
				return; 
			case RMPackage.EINTERFACE_TYPE_BODY:
				sequence_EInterfaceTypeBody(context, (EInterfaceTypeBody) semanticObject); 
				return; 
			case RMPackage.EINTERFACE_TYPES:
				sequence_EInterfaceTypes(context, (EInterfaceTypes) semanticObject); 
				return; 
			case RMPackage.EINTERFACES:
				sequence_EInterfaces(context, (EInterfaces) semanticObject); 
				return; 
			case RMPackage.ELIST:
				sequence_ELIST(context, (ELIST) semanticObject); 
				return; 
			case RMPackage.ELENGTH:
				sequence_ELength(context, (ELength) semanticObject); 
				return; 
			case RMPackage.ELESS_OR_EQUAL:
				sequence_ELessOrEqual(context, (ELessOrEqual) semanticObject); 
				return; 
			case RMPackage.ELESS_THAN:
				sequence_ELessThan(context, (ELessThan) semanticObject); 
				return; 
			case RMPackage.EMAP:
				sequence_EMAP(context, (EMAP) semanticObject); 
				return; 
			case RMPackage.EMAP_ENTRY:
				sequence_EMapEntry(context, (EMapEntry) semanticObject); 
				return; 
			case RMPackage.EMAX_LENGTH:
				sequence_EMaxLength(context, (EMaxLength) semanticObject); 
				return; 
			case RMPackage.EMIN_LENGTH:
				sequence_EMinLength(context, (EMinLength) semanticObject); 
				return; 
			case RMPackage.ENODE_TYPE:
				sequence_ENodeType(context, (ENodeType) semanticObject); 
				return; 
			case RMPackage.ENODE_TYPE_BODY:
				sequence_ENodeTypeBody(context, (ENodeTypeBody) semanticObject); 
				return; 
			case RMPackage.ENODE_TYPE_REF:
				sequence_ENodeTypeRef(context, (ENodeTypeRef) semanticObject); 
				return; 
			case RMPackage.ENODE_TYPES:
				sequence_ENodeTypes(context, (ENodeTypes) semanticObject); 
				return; 
			case RMPackage.EOPERATION_DEFINITION:
				sequence_EOperationDefinition(context, (EOperationDefinition) semanticObject); 
				return; 
			case RMPackage.EOPERATION_DEFINITION_BODY:
				sequence_EOperationDefinitionBody(context, (EOperationDefinitionBody) semanticObject); 
				return; 
			case RMPackage.EOPERATIONS:
				sequence_EOperations(context, (EOperations) semanticObject); 
				return; 
			case RMPackage.EPARAMETER_DEFINITION:
				sequence_EParameterDefinition(context, (EParameterDefinition) semanticObject); 
				return; 
			case RMPackage.EPARAMETER_DEFINITION_BODY:
				sequence_EParameterDefinitionBody(context, (EParameterDefinitionBody) semanticObject); 
				return; 
			case RMPackage.EPOLICY_TYPE:
				sequence_EPolicyType(context, (EPolicyType) semanticObject); 
				return; 
			case RMPackage.EPOLICY_TYPE_BODY:
				sequence_EPolicyTypeBody(context, (EPolicyTypeBody) semanticObject); 
				return; 
			case RMPackage.EPOLICY_TYPES:
				sequence_EPolicyTypes(context, (EPolicyTypes) semanticObject); 
				return; 
			case RMPackage.EPROPERTIES:
				sequence_EProperties(context, (EProperties) semanticObject); 
				return; 
			case RMPackage.EPROPERTY_DEFINITION:
				sequence_EPropertyDefinition(context, (EPropertyDefinition) semanticObject); 
				return; 
			case RMPackage.EPROPERTY_DEFINITION_BODY:
				sequence_EPropertyDefinitionBody(context, (EPropertyDefinitionBody) semanticObject); 
				return; 
			case RMPackage.ERELATIONSHIP_TYPE:
				sequence_ERelationshipType(context, (ERelationshipType) semanticObject); 
				return; 
			case RMPackage.ERELATIONSHIP_TYPE_BODY:
				sequence_ERelationshipTypeBody(context, (ERelationshipTypeBody) semanticObject); 
				return; 
			case RMPackage.ERELATIONSHIP_TYPES:
				sequence_ERelationshipTypes(context, (ERelationshipTypes) semanticObject); 
				return; 
			case RMPackage.EREQUIREMENT_DEFINITION:
				sequence_ERequirementDefinition(context, (ERequirementDefinition) semanticObject); 
				return; 
			case RMPackage.EREQUIREMENT_DEFINITION_BODY:
				sequence_ERequirementDefinitionBody(context, (ERequirementDefinitionBody) semanticObject); 
				return; 
			case RMPackage.EREQUIREMENTS:
				sequence_ERequirements(context, (ERequirements) semanticObject); 
				return; 
			case RMPackage.ESTRING:
				sequence_ESTRING(context, (ESTRING) semanticObject); 
				return; 
			case RMPackage.EVALID_SOURCE_TYPE:
				sequence_EValidSourceType(context, (EValidSourceType) semanticObject); 
				return; 
			case RMPackage.EVALID_TARGET_TYPES:
				sequence_EValidTargetTypes(context, (EValidTargetTypes) semanticObject); 
				return; 
			case RMPackage.EVALID_VALUES:
				sequence_EValid_Values(context, (EValid_Values) semanticObject); 
				return; 
			case RMPackage.GET_ATTRIBUTE:
				sequence_GetAttribute(context, (GetAttribute) semanticObject); 
				return; 
			case RMPackage.GET_ATTRIBUTE_BODY:
				sequence_GetAttributeBody(context, (GetAttributeBody) semanticObject); 
				return; 
			case RMPackage.GET_INPUT:
				sequence_GetInput(context, (GetInput) semanticObject); 
				return; 
			case RMPackage.GET_PROPERTY:
				sequence_GetProperty(context, (GetProperty) semanticObject); 
				return; 
			case RMPackage.GET_PROPERTY_BODY:
				sequence_GetPropertyBody(context, (GetPropertyBody) semanticObject); 
				return; 
			case RMPackage.RM_MODEL:
				sequence_RM_Model(context, (RM_Model) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     EArtifactTypeBody returns EArtifactTypeBody
	 *
	 * Constraint:
	 *     (superType=[EArtifactType|QUALIFIED_NAME] | description=STRING | mime_type=STRING | file_ext=STRING)*
	 */
	protected void sequence_EArtifactTypeBody(ISerializationContext context, EArtifactTypeBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EArtifactType returns EArtifactType
	 *
	 * Constraint:
	 *     (name=QUALIFIED_NAME artifact=EArtifactTypeBody)
	 */
	protected void sequence_EArtifactType(ISerializationContext context, EArtifactType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EARTIFACT_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EARTIFACT_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EARTIFACT_TYPE__ARTIFACT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EARTIFACT_TYPE__ARTIFACT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEArtifactTypeAccess().getNameQUALIFIED_NAMETerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEArtifactTypeAccess().getArtifactEArtifactTypeBodyParserRuleCall_3_0(), semanticObject.getArtifact());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EArtifactTypes returns EArtifactTypes
	 *
	 * Constraint:
	 *     artifactTypes+=EArtifactType+
	 */
	protected void sequence_EArtifactTypes(ISerializationContext context, EArtifactTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAttributeDefinitionBody returns EAttributeDefinitionBody
	 *
	 * Constraint:
	 *     (type=[EDataType|EDataTypeName] | description=STRING | entry_schema=[EDataType|EDataTypeName])+
	 */
	protected void sequence_EAttributeDefinitionBody(ISerializationContext context, EAttributeDefinitionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAttributeDefinition returns EAttributeDefinition
	 *
	 * Constraint:
	 *     (name=ID attribute=EAttributeDefinitionBody)
	 */
	protected void sequence_EAttributeDefinition(ISerializationContext context, EAttributeDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EATTRIBUTE_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EATTRIBUTE_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EATTRIBUTE_DEFINITION__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EATTRIBUTE_DEFINITION__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEAttributeDefinitionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEAttributeDefinitionAccess().getAttributeEAttributeDefinitionBodyParserRuleCall_3_0(), semanticObject.getAttribute());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EAttributes returns EAttributes
	 *
	 * Constraint:
	 *     attributes+=EAttributeDefinition*
	 */
	protected void sequence_EAttributes(ISerializationContext context, EAttributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ECapabilities returns ECapabilities
	 *
	 * Constraint:
	 *     capabilities+=ECapabilityDefinition*
	 */
	protected void sequence_ECapabilities(ISerializationContext context, ECapabilities semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ECapabilityDefinitionBody returns ECapabilityDefinitionBody
	 *
	 * Constraint:
	 *     (
	 *         (type=[ECapabilityType|QUALIFIED_NAME] | description=STRING | properties=EProperties | attributes=EAttributes | valid_source_types+=EValidSourceType)? 
	 *         (occurrences_start=STRING occurrences_end=STRING)?
	 *     )+
	 */
	protected void sequence_ECapabilityDefinitionBody(ISerializationContext context, ECapabilityDefinitionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ECapabilityDefinition returns ECapabilityDefinition
	 *     EReqOrCap returns ECapabilityDefinition
	 *
	 * Constraint:
	 *     (name=ID capability=ECapabilityDefinitionBody)
	 */
	protected void sequence_ECapabilityDefinition(ISerializationContext context, ECapabilityDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EREQ_OR_CAP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EREQ_OR_CAP__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.ECAPABILITY_DEFINITION__CAPABILITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.ECAPABILITY_DEFINITION__CAPABILITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getECapabilityDefinitionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getECapabilityDefinitionAccess().getCapabilityECapabilityDefinitionBodyParserRuleCall_3_0(), semanticObject.getCapability());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ECapabilityTypeBody returns ECapabilityTypeBody
	 *
	 * Constraint:
	 *     (superType=[ECapabilityType|QUALIFIED_NAME] | description=STRING | properties=EProperties | atributes=EAttributes)*
	 */
	protected void sequence_ECapabilityTypeBody(ISerializationContext context, ECapabilityTypeBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ECapabilityTypeRef returns ECapabilityTypeRef
	 *
	 * Constraint:
	 *     name=[ECapabilityType|QUALIFIED_NAME]
	 */
	protected void sequence_ECapabilityTypeRef(ISerializationContext context, ECapabilityTypeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.ECAPABILITY_TYPE_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.ECAPABILITY_TYPE_REF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getECapabilityTypeRefAccess().getNameECapabilityTypeQUALIFIED_NAMETerminalRuleCall_0_1(), semanticObject.eGet(RMPackage.Literals.ECAPABILITY_TYPE_REF__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ECapabilityType returns ECapabilityType
	 *
	 * Constraint:
	 *     (name=QUALIFIED_NAME capability=ECapabilityTypeBody)
	 */
	protected void sequence_ECapabilityType(ISerializationContext context, ECapabilityType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.ECAPABILITY_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.ECAPABILITY_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.ECAPABILITY_TYPE__CAPABILITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.ECAPABILITY_TYPE__CAPABILITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getECapabilityTypeAccess().getNameQUALIFIED_NAMETerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getECapabilityTypeAccess().getCapabilityECapabilityTypeBodyParserRuleCall_3_0(), semanticObject.getCapability());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ECapabilityTypes returns ECapabilityTypes
	 *
	 * Constraint:
	 *     capabilityTypes+=ECapabilityType+
	 */
	protected void sequence_ECapabilityTypes(ISerializationContext context, ECapabilityTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EConstraints returns EConstraints
	 *
	 * Constraint:
	 *     constraints+=EConstraint*
	 */
	protected void sequence_EConstraints(ISerializationContext context, EConstraints semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EDataTypeBody returns EDataTypeBody
	 *
	 * Constraint:
	 *     (superType=[EDataType|EDataTypeName] | description=STRING | constraints=EConstraints | properties=EProperties)*
	 */
	protected void sequence_EDataTypeBody(ISerializationContext context, EDataTypeBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EDataType returns EDataType
	 *
	 * Constraint:
	 *     (name=EDataTypeName data=EDataTypeBody)
	 */
	protected void sequence_EDataType(ISerializationContext context, EDataType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EDATA_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EDATA_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EDATA_TYPE__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EDATA_TYPE__DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEDataTypeAccess().getNameEDataTypeNameParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEDataTypeAccess().getDataEDataTypeBodyParserRuleCall_3_0(), semanticObject.getData());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EDataTypes returns EDataTypes
	 *
	 * Constraint:
	 *     dataTypes+=EDataType+
	 */
	protected void sequence_EDataTypes(ISerializationContext context, EDataTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EDependencies returns EDependencies
	 *
	 * Constraint:
	 *     (deps+=STRING deps+=STRING*)
	 */
	protected void sequence_EDependencies(ISerializationContext context, EDependencies semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EConstraint returns EEqual
	 *     EEqual returns EEqual
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_EEqual(ISerializationContext context, EEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EEQUAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EEQUAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEEqualAccess().getValSTRINGTerminalRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EConstraint returns EGreaterOrEqual
	 *     EGreaterOrEqual returns EGreaterOrEqual
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_EGreaterOrEqual(ISerializationContext context, EGreaterOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EGREATER_OR_EQUAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EGREATER_OR_EQUAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEGreaterOrEqualAccess().getValSTRINGTerminalRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EConstraint returns EGreaterThan
	 *     EGreaterThan returns EGreaterThan
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_EGreaterThan(ISerializationContext context, EGreaterThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EGREATER_THAN__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EGREATER_THAN__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEGreaterThanAccess().getValSTRINGTerminalRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EImplementation returns EImplementation
	 *
	 * Constraint:
	 *     (primary=STRING | dependencies=EDependencies)*
	 */
	protected void sequence_EImplementation(ISerializationContext context, EImplementation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EConstraint returns EInRange
	 *     EInRange returns EInRange
	 *
	 * Constraint:
	 *     (start=STRING end=STRING)
	 */
	protected void sequence_EInRange(ISerializationContext context, EInRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EIN_RANGE__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EIN_RANGE__START));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EIN_RANGE__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EIN_RANGE__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEInRangeAccess().getStartSTRINGTerminalRuleCall_2_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getEInRangeAccess().getEndSTRINGTerminalRuleCall_4_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EInputs returns EInputs
	 *
	 * Constraint:
	 *     inputs+=EParameterDefinition*
	 */
	protected void sequence_EInputs(ISerializationContext context, EInputs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EInterfaceDefinitionBody returns EInterfaceDefinitionBody
	 *
	 * Constraint:
	 *     (type=[EInterfaceType|QUALIFIED_NAME] | inputs=EProperties | operations=EOperations)+
	 */
	protected void sequence_EInterfaceDefinitionBody(ISerializationContext context, EInterfaceDefinitionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EInterfaceDefinition returns EInterfaceDefinition
	 *
	 * Constraint:
	 *     (name=ID interface=EInterfaceDefinitionBody)
	 */
	protected void sequence_EInterfaceDefinition(ISerializationContext context, EInterfaceDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EINTERFACE_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EINTERFACE_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EINTERFACE_DEFINITION__INTERFACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EINTERFACE_DEFINITION__INTERFACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEInterfaceDefinitionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEInterfaceDefinitionAccess().getInterfaceEInterfaceDefinitionBodyParserRuleCall_3_0(), semanticObject.getInterface());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EInterfaceTypeBody returns EInterfaceTypeBody
	 *
	 * Constraint:
	 *     (superType=[EInterfaceType|QUALIFIED_NAME] | description=STRING | inputs=EProperties | operations=EOperations)*
	 */
	protected void sequence_EInterfaceTypeBody(ISerializationContext context, EInterfaceTypeBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EInterfaceType returns EInterfaceType
	 *
	 * Constraint:
	 *     (name=QUALIFIED_NAME interface=EInterfaceTypeBody)
	 */
	protected void sequence_EInterfaceType(ISerializationContext context, EInterfaceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EINTERFACE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EINTERFACE_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EINTERFACE_TYPE__INTERFACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EINTERFACE_TYPE__INTERFACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEInterfaceTypeAccess().getNameQUALIFIED_NAMETerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEInterfaceTypeAccess().getInterfaceEInterfaceTypeBodyParserRuleCall_3_0(), semanticObject.getInterface());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EInterfaceTypes returns EInterfaceTypes
	 *
	 * Constraint:
	 *     interfaceTypes+=EInterfaceType+
	 */
	protected void sequence_EInterfaceTypes(ISerializationContext context, EInterfaceTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EInterfaces returns EInterfaces
	 *
	 * Constraint:
	 *     interfaces+=EInterfaceDefinition*
	 */
	protected void sequence_EInterfaces(ISerializationContext context, EInterfaces semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ELIST returns ELIST
	 *     EPropertyAssignmentValue returns ELIST
	 *
	 * Constraint:
	 *     (list+=STRING list+=STRING*)
	 */
	protected void sequence_ELIST(ISerializationContext context, ELIST semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EConstraint returns ELength
	 *     ELength returns ELength
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_ELength(ISerializationContext context, ELength semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.ELENGTH__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.ELENGTH__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getELengthAccess().getValSTRINGTerminalRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EConstraint returns ELessOrEqual
	 *     ELessOrEqual returns ELessOrEqual
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_ELessOrEqual(ISerializationContext context, ELessOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.ELESS_OR_EQUAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.ELESS_OR_EQUAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getELessOrEqualAccess().getValSTRINGTerminalRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EConstraint returns ELessThan
	 *     ELessThan returns ELessThan
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_ELessThan(ISerializationContext context, ELessThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.ELESS_THAN__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.ELESS_THAN__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getELessThanAccess().getValSTRINGTerminalRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EPropertyAssignmentValue returns EMAP
	 *     EMAP returns EMAP
	 *
	 * Constraint:
	 *     map+=EMapEntry+
	 */
	protected void sequence_EMAP(ISerializationContext context, EMAP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EMapEntry returns EMapEntry
	 *
	 * Constraint:
	 *     (key=ID value=EPropertyAssignmentValue)
	 */
	protected void sequence_EMapEntry(ISerializationContext context, EMapEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EMAP_ENTRY__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EMAP_ENTRY__KEY));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EMAP_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EMAP_ENTRY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEMapEntryAccess().getKeyIDTerminalRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getEMapEntryAccess().getValueEPropertyAssignmentValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EConstraint returns EMaxLength
	 *     EMaxLength returns EMaxLength
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_EMaxLength(ISerializationContext context, EMaxLength semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EMAX_LENGTH__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EMAX_LENGTH__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEMaxLengthAccess().getValSTRINGTerminalRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EConstraint returns EMinLength
	 *     EMinLength returns EMinLength
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_EMinLength(ISerializationContext context, EMinLength semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EMIN_LENGTH__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EMIN_LENGTH__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEMinLengthAccess().getValSTRINGTerminalRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ENodeTypeBody returns ENodeTypeBody
	 *
	 * Constraint:
	 *     (
	 *         superType=[ENodeType|QUALIFIED_NAME] | 
	 *         description=STRING | 
	 *         properties=EProperties | 
	 *         attributes=EAttributes | 
	 *         interfaces=EInterfaces | 
	 *         capabilities=ECapabilities | 
	 *         requirements=ERequirements
	 *     )*
	 */
	protected void sequence_ENodeTypeBody(ISerializationContext context, ENodeTypeBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ENodeTypeRef returns ENodeTypeRef
	 *
	 * Constraint:
	 *     name=[ENodeType|QUALIFIED_NAME]
	 */
	protected void sequence_ENodeTypeRef(ISerializationContext context, ENodeTypeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.ENODE_TYPE_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.ENODE_TYPE_REF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getENodeTypeRefAccess().getNameENodeTypeQUALIFIED_NAMETerminalRuleCall_0_1(), semanticObject.eGet(RMPackage.Literals.ENODE_TYPE_REF__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ENodeType returns ENodeType
	 *
	 * Constraint:
	 *     (name=QUALIFIED_NAME node=ENodeTypeBody)
	 */
	protected void sequence_ENodeType(ISerializationContext context, ENodeType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.ENODE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.ENODE_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.ENODE_TYPE__NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.ENODE_TYPE__NODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getENodeTypeAccess().getNameQUALIFIED_NAMETerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getENodeTypeAccess().getNodeENodeTypeBodyParserRuleCall_3_0(), semanticObject.getNode());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ENodeTypes returns ENodeTypes
	 *
	 * Constraint:
	 *     nodeTypes+=ENodeType+
	 */
	protected void sequence_ENodeTypes(ISerializationContext context, ENodeTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EOperationDefinitionBody returns EOperationDefinitionBody
	 *
	 * Constraint:
	 *     (description=STRING | inputs=EInputs | implementation=EImplementation)*
	 */
	protected void sequence_EOperationDefinitionBody(ISerializationContext context, EOperationDefinitionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EOperationDefinition returns EOperationDefinition
	 *
	 * Constraint:
	 *     (name=ID operation=EOperationDefinitionBody)
	 */
	protected void sequence_EOperationDefinition(ISerializationContext context, EOperationDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EOPERATION_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EOPERATION_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EOPERATION_DEFINITION__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EOPERATION_DEFINITION__OPERATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEOperationDefinitionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEOperationDefinitionAccess().getOperationEOperationDefinitionBodyParserRuleCall_3_0(), semanticObject.getOperation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EOperations returns EOperations
	 *
	 * Constraint:
	 *     operations+=EOperationDefinition*
	 */
	protected void sequence_EOperations(ISerializationContext context, EOperations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EParameterDefinitionBody returns EParameterDefinitionBody
	 *
	 * Constraint:
	 *     (type=[EDataType|EDataTypeName] | value=EValueExpression | default=EValueExpression)*
	 */
	protected void sequence_EParameterDefinitionBody(ISerializationContext context, EParameterDefinitionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EParameterDefinition returns EParameterDefinition
	 *
	 * Constraint:
	 *     (name=ID parameter=EParameterDefinitionBody)
	 */
	protected void sequence_EParameterDefinition(ISerializationContext context, EParameterDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EPARAMETER_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EPARAMETER_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EPARAMETER_DEFINITION__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EPARAMETER_DEFINITION__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEParameterDefinitionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEParameterDefinitionAccess().getParameterEParameterDefinitionBodyParserRuleCall_3_0(), semanticObject.getParameter());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EPolicyTypeBody returns EPolicyTypeBody
	 *
	 * Constraint:
	 *     (superType=[EPolicyType|QUALIFIED_NAME] | description=STRING)*
	 */
	protected void sequence_EPolicyTypeBody(ISerializationContext context, EPolicyTypeBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EPolicyType returns EPolicyType
	 *
	 * Constraint:
	 *     (name=QUALIFIED_NAME policy=EPolicyTypeBody)
	 */
	protected void sequence_EPolicyType(ISerializationContext context, EPolicyType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EPOLICY_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EPOLICY_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EPOLICY_TYPE__POLICY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EPOLICY_TYPE__POLICY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEPolicyTypeAccess().getNameQUALIFIED_NAMETerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEPolicyTypeAccess().getPolicyEPolicyTypeBodyParserRuleCall_3_0(), semanticObject.getPolicy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EPolicyTypes returns EPolicyTypes
	 *
	 * Constraint:
	 *     policyTypes+=EPolicyType+
	 */
	protected void sequence_EPolicyTypes(ISerializationContext context, EPolicyTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EProperties returns EProperties
	 *
	 * Constraint:
	 *     properties+=EPropertyDefinition*
	 */
	protected void sequence_EProperties(ISerializationContext context, EProperties semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EPropertyDefinitionBody returns EPropertyDefinitionBody
	 *
	 * Constraint:
	 *     (
	 *         type=[EDataType|EDataTypeName] | 
	 *         description=STRING | 
	 *         required=BOOLEAN | 
	 *         default=EValueExpression | 
	 *         status=STRING | 
	 *         constraints=EConstraints | 
	 *         entry_schema=[EDataType|EDataTypeName]
	 *     )+
	 */
	protected void sequence_EPropertyDefinitionBody(ISerializationContext context, EPropertyDefinitionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EPropertyDefinition returns EPropertyDefinition
	 *
	 * Constraint:
	 *     (name=ID property=EPropertyDefinitionBody)
	 */
	protected void sequence_EPropertyDefinition(ISerializationContext context, EPropertyDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EPROPERTY_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EPROPERTY_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EPROPERTY_DEFINITION__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EPROPERTY_DEFINITION__PROPERTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEPropertyDefinitionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEPropertyDefinitionAccess().getPropertyEPropertyDefinitionBodyParserRuleCall_3_0(), semanticObject.getProperty());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ERelationshipTypeBody returns ERelationshipTypeBody
	 *
	 * Constraint:
	 *     (
	 *         superType=[ERelationshipType|QUALIFIED_NAME] | 
	 *         description=STRING | 
	 *         properties=EProperties | 
	 *         atributes=EAttributes | 
	 *         interfaces=EInterfaces | 
	 *         valid_target_types=EValidTargetTypes
	 *     )*
	 */
	protected void sequence_ERelationshipTypeBody(ISerializationContext context, ERelationshipTypeBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ERelationshipType returns ERelationshipType
	 *
	 * Constraint:
	 *     (name=QUALIFIED_NAME relationship=ERelationshipTypeBody)
	 */
	protected void sequence_ERelationshipType(ISerializationContext context, ERelationshipType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.ERELATIONSHIP_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.ERELATIONSHIP_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.ERELATIONSHIP_TYPE__RELATIONSHIP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.ERELATIONSHIP_TYPE__RELATIONSHIP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getERelationshipTypeAccess().getNameQUALIFIED_NAMETerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getERelationshipTypeAccess().getRelationshipERelationshipTypeBodyParserRuleCall_3_0(), semanticObject.getRelationship());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ERelationshipTypes returns ERelationshipTypes
	 *
	 * Constraint:
	 *     relationshipTypes+=ERelationshipType+
	 */
	protected void sequence_ERelationshipTypes(ISerializationContext context, ERelationshipTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ERequirementDefinitionBody returns ERequirementDefinitionBody
	 *
	 * Constraint:
	 *     (
	 *         capability=[ECapabilityType|QUALIFIED_NAME] | 
	 *         node=[ENodeType|QUALIFIED_NAME] | 
	 *         relationship=[ERelationshipType|QUALIFIED_NAME] | 
	 *         (start=STRING end=STRING)
	 *     )+
	 */
	protected void sequence_ERequirementDefinitionBody(ISerializationContext context, ERequirementDefinitionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ERequirementDefinition returns ERequirementDefinition
	 *     EReqOrCap returns ERequirementDefinition
	 *
	 * Constraint:
	 *     (name=ID requirement=ERequirementDefinitionBody)
	 */
	protected void sequence_ERequirementDefinition(ISerializationContext context, ERequirementDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EREQ_OR_CAP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EREQ_OR_CAP__NAME));
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EREQUIREMENT_DEFINITION__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EREQUIREMENT_DEFINITION__REQUIREMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getERequirementDefinitionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getERequirementDefinitionAccess().getRequirementERequirementDefinitionBodyParserRuleCall_3_0(), semanticObject.getRequirement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ERequirements returns ERequirements
	 *
	 * Constraint:
	 *     requirements+=ERequirementDefinition*
	 */
	protected void sequence_ERequirements(ISerializationContext context, ERequirements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EValueExpression returns ESTRING
	 *     EPropertyAssignmentValue returns ESTRING
	 *     ESTRING returns ESTRING
	 *
	 * Constraint:
	 *     string=STRING
	 */
	protected void sequence_ESTRING(ISerializationContext context, ESTRING semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.ESTRING__STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.ESTRING__STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getESTRINGAccess().getStringSTRINGTerminalRuleCall_0(), semanticObject.getString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EValidSourceType returns EValidSourceType
	 *
	 * Constraint:
	 *     (sourceTypes+=ENodeTypeRef sourceType+=ENodeTypeRef*)
	 */
	protected void sequence_EValidSourceType(ISerializationContext context, EValidSourceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EValidTargetTypes returns EValidTargetTypes
	 *
	 * Constraint:
	 *     (targetTypes+=ECapabilityTypeRef sourceType+=ECapabilityTypeRef*)
	 */
	protected void sequence_EValidTargetTypes(ISerializationContext context, EValidTargetTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EConstraint returns EValid_Values
	 *     EValid_Values returns EValid_Values
	 *
	 * Constraint:
	 *     val=ELIST
	 */
	protected void sequence_EValid_Values(ISerializationContext context, EValid_Values semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.EVALID_VALUES__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.EVALID_VALUES__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEValid_ValuesAccess().getValELISTParserRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GetAttributeBody returns GetAttributeBody
	 *
	 * Constraint:
	 *     (attribute=[EAttributeDefinition|QUALIFIED_NAME] | entity=ENTITY | req_cap=[EReqOrCap|QUALIFIED_NAME])+
	 */
	protected void sequence_GetAttributeBody(ISerializationContext context, GetAttributeBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EValueExpression returns GetAttribute
	 *     EFunction returns GetAttribute
	 *     GetAttribute returns GetAttribute
	 *     EPropertyAssignmentValue returns GetAttribute
	 *
	 * Constraint:
	 *     attribute=GetAttributeBody
	 */
	protected void sequence_GetAttribute(ISerializationContext context, GetAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.GET_ATTRIBUTE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.GET_ATTRIBUTE__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetAttributeAccess().getAttributeGetAttributeBodyParserRuleCall_2_0(), semanticObject.getAttribute());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EValueExpression returns GetInput
	 *     EFunction returns GetInput
	 *     GetInput returns GetInput
	 *     EPropertyAssignmentValue returns GetInput
	 *
	 * Constraint:
	 *     input=[EParameterDefinition|ID]
	 */
	protected void sequence_GetInput(ISerializationContext context, GetInput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.GET_INPUT__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.GET_INPUT__INPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetInputAccess().getInputEParameterDefinitionIDTerminalRuleCall_1_0_1(), semanticObject.eGet(RMPackage.Literals.GET_INPUT__INPUT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GetPropertyBody returns GetPropertyBody
	 *
	 * Constraint:
	 *     (property=[EPropertyDefinition|QUALIFIED_NAME] | entity=ENTITY | req_cap=[EReqOrCap|QUALIFIED_NAME])+
	 */
	protected void sequence_GetPropertyBody(ISerializationContext context, GetPropertyBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EValueExpression returns GetProperty
	 *     EFunction returns GetProperty
	 *     GetProperty returns GetProperty
	 *     EPropertyAssignmentValue returns GetProperty
	 *
	 * Constraint:
	 *     property=GetPropertyBody
	 */
	protected void sequence_GetProperty(ISerializationContext context, GetProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RMPackage.Literals.GET_PROPERTY__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RMPackage.Literals.GET_PROPERTY__PROPERTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetPropertyAccess().getPropertyGetPropertyBodyParserRuleCall_2_0(), semanticObject.getProperty());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RM_Model returns RM_Model
	 *
	 * Constraint:
	 *     (
	 *         dataTypes=EDataTypes | 
	 *         artifactTypes=EArtifactTypes | 
	 *         capabilityTypes=ECapabilityTypes | 
	 *         interfaceTypes=EInterfaceTypes | 
	 *         relationshipTypes=ERelationshipTypes | 
	 *         nodeTypes=ENodeTypes | 
	 *         policyTypes=EPolicyTypes
	 *     )+
	 */
	protected void sequence_RM_Model(ISerializationContext context, RM_Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
