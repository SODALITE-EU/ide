/*******************************************************************************
 * Copyright (c) 2019 Atos Spain S.A.
 * This program and the accompanying materials
 * are made available under the terms of the Apache Public License 2.0 (APL2)
 * which accompanies this distribution, and is available at
 * https://apache.org/licenses/LICENSE-2.0
 *
 * Contributors:
 *     Jesús Gorroñogoitia - Design and implementation
 *******************************************************************************/

grammar org.sodalite.dsl.Alerting with org.eclipse.xtext.common.Terminals

generate alerting "http://www.sodalite.org/dsl/Alerting"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Alerting_Model:
	(groups+=EGroups)*
;
	
EGroups:
	groups += EGroup
;

EGroup:
	'group:' name = ID 
	BEGIN
	(rules+=ERule)*
	END
;

ERule:
	'alert:' alert = ID
	BEGIN
		'expr:' 
		BEGIN
			expr = EExpression
		END
		('for:' duration = STRING)?
		('labels:'
		BEGIN
			(labels+=ELabel)*
		END)?
		('annotations:'
		BEGIN
			(annotations+=ELabel)*
		END)?
	END
;



ELabel:
	key = ID ":" value = STRING
;

EExpression:
	expr=EStatement 
;

EStatement:
	EUniaryLogicOperator | EBinaryLogicOperation | EVectorExpr
;

EVectorMatching:
	type = EVectorMatchingType '(' labels = ELabelList ')' expr=EVectorExpr
;

ELabelList:
	{ELabelList} (list += ESingleLabel)? (',' list += ESingleLabel)*
;

ESingleLabel:
	label = ID
;

EAggregationExpr:
	oper = EAggregationOper ( modifier=EAggregationOperModifier '(' labels = ELabelList ')')? '(' expr = EVectorExpr ')'
;

EAggregationOper:
	oper = 'sum' | {EAggregationOper} 'min' | {EAggregationOper} 'max' | {EAggregationOper} 'avg' | 
	{EAggregationOper} 'group' | {EAggregationOper} 'stddev' | {EAggregationOper} 'stdvar' | 
	{EAggregationOper} 'count' | {EAggregationOper} 'count_values' | {EAggregationOper} 'bottomk' | 
	{EAggregationOper} 'topk' | {EAggregationOper} 'quantile'
;

EAggregationOperModifier:
	mod = 'without' | {EAggregationOperModifier} 'by'
;


EVectorExpr:
	ENUMBER | EFunctionExpr | EMetricExpr | EAritmeticExpr | EVectorMatching | EAggregationExpr
;

EAritmeticExpr:
	'(' loperad = EVectorExpr oper=EBinaryOperator roperad = EVectorExpr  ')'
;

EFunctionExpr:
	function = EFunctionType '(' (expr = EVectorExpr)? ')'
;

EFunctionType:
	type = 'increase' | {EFunctionType} 'rate' | {EFunctionType} 'vector'
;

EMetricExpr:
	type = EMetricType '{' (tags += ETag)? (',' tags += ETag)* '}' ('[' period = STRING ']')?
;

ETag:
	key=ID oper=EOperAssociation value=STRING
;

EOperAssociation:
	type = '=' | {EOperAssociation} '=~' | {EOperAssociation} '!=' | {EOperAssociation} '~'
;

EMetricType:
	type = 'node_cpu_seconds_total' | {EMetricType} 'node_network_receive_bytes_total' | {EMetricType} 'node_filesystem_readonly' | {EMetricType} 'node_filesystem_avail_bytes' | {EMetricType} 'node_filesystem_size_bytes'
;

EVectorMatchingType:
	type = 'on' | {EVectorMatchingType} 'ignoring'
;

EOperationStatement:
	oper = EBinaryOperator
	BEGIN
		stmt1 = EStatement
		stmt2 = EStatement
	END
;

ENUMBER:
	value = NUMBER
;

EBinaryOperator:
	EAritmeticOperator | EComparisonOperator
;

EAritmeticOperator:
	type = '+' | {EAritmeticOperator} '-' | {EAritmeticOperator} '*' | {EAritmeticOperator} '/' | {EAritmeticOperator} '%' | {EAritmeticOperator} '^'
;

EComparisonOperator:
	type = '<' | {EComparisonOperator} '>' | {EComparisonOperator} '<=' | {EComparisonOperator} '>=' | {EComparisonOperator} '=='
;


EUniaryLogicOperator:
	Enot
;

EBinaryLogicOperation:
	EAnd | EOr | EUnless
;

Enot:
	'not:'
	BEGIN
	not=EExpression
	END
;

EAnd:
	'and:'
	BEGIN
	first=EExpression
	second=EExpression
	END
;
	
EOr:
	'or:'
	BEGIN
	first=EExpression
	second=EExpression
	END
;

EUnless:
	'unless:'
	BEGIN
	first=EExpression
	second=EExpression
	END
;

NUMBER returns ecore::EFloat: '-'? INT ('.' INT)?;
	
//Positional blocks delimited with indentation
terminal BEGIN: 'synthetic:BEGIN';
terminal END: 'synthetic:END';

terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false';
	
