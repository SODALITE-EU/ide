/*
 * generated by Xtext 2.22.0
 */
package org.sodalite.dsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.emf.common.util.URI
import org.sodalite.dsl.alerting.EGroup
import org.sodalite.dsl.alerting.ERule
import org.sodalite.dsl.alerting.ELabel
import org.sodalite.dsl.alerting.ELogicExpr
import org.sodalite.dsl.alerting.EVectorExpr
import org.sodalite.dsl.alerting.EStatement
import org.sodalite.dsl.alerting.EBinaryLogicExpr
import org.sodalite.dsl.alerting.Enot
import org.sodalite.dsl.alerting.EExpression
import org.sodalite.dsl.alerting.ENUMBER
import org.sodalite.dsl.alerting.EFunctionExpr
import org.sodalite.dsl.alerting.EMetricExpr
import org.sodalite.dsl.alerting.EAritmeticExpr
import org.sodalite.dsl.alerting.EVectorMatching
import org.sodalite.dsl.alerting.EAggregationExpr
import org.sodalite.dsl.alerting.ELabelList
import java.util.List
import org.eclipse.emf.common.util.EList
import org.sodalite.dsl.alerting.ESingleLabel
import org.sodalite.dsl.alerting.ETag
import java.text.DecimalFormat

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class AlertingGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val filename = getFilename(resource.URI)
		fsa.generateFile(filename,  compileAlerting (resource))
	}
	
	def compileAlerting(Resource r) '''
	groups:
	«FOR g:r.allContents.toIterable.filter(EGroup)»
		«g.compile»
	«ENDFOR»
	'''
	
	def compile(EGroup g) '''
	- name: «g.name»
	  rules:
	  «FOR r:g.rules»
	  «r.compile»
	  «ENDFOR»
	'''
	
	def compile(ERule r) '''
	  - alert: «r.alert»
	    expr: «r.expr.compile»
	    «IF r.duration !== null»
	    for: «r.duration»
	    «ENDIF»
	    «IF r.labels !== null»
	    labels:
	      «FOR l:r.labels»
	      «l.compile»
	      «ENDFOR»
	    «ENDIF»
	    «IF r.annotations !== null»
	    annotations:
	      «FOR a:r.annotations»
	      «a.compile»
	      «ENDFOR»
	      monitoring_id: '{{ $labels.monitoring_id }}'
	      instance: '{{ $labels.instance }}'
	      hpc: '{{ $labels.hpc }}'
	    «ENDIF»
	'''
	
	def compile(EExpression e) '''
		«trim(e.expr.compile.toString)»
	'''
	
	def compile(EStatement s) '''
	«IF s instanceof ELogicExpr»
	«(s as ELogicExpr).compile»	
	«ELSEIF s instanceof EVectorExpr»
	«(s as EVectorExpr).compile»
	«ENDIF»
	'''
	
	def compile(ELogicExpr le) '''
	«IF le instanceof Enot»
	«(le as Enot).compile»	
	«ELSEIF le instanceof EBinaryLogicExpr»
	«(le as EBinaryLogicExpr).compile»
	«ENDIF»
	'''
	
	def compile(EVectorExpr ve) '''
	«IF ve instanceof ENUMBER»
	«(ve as ENUMBER).compile»	
	«ELSEIF ve instanceof EFunctionExpr»
	«(ve as EFunctionExpr).compile»
	«ELSEIF ve instanceof EMetricExpr»
	«(ve as EMetricExpr).compile»
	«ELSEIF ve instanceof EAritmeticExpr»
	«(ve as EAritmeticExpr).compile»
	«ELSEIF ve instanceof EVectorMatching»
	«(ve as EVectorMatching).compile»
	«ELSEIF ve instanceof EAggregationExpr»
	«(ve as EAggregationExpr).compile»
	«ENDIF»
	'''
	
	def compile(ENUMBER n) '''
	«formatNumber(n.value)»
	'''
	
	def formatNumber(float f){
		val DecimalFormat df = new DecimalFormat("#.##");
		return df.format(f);
	}
	
	def compile(EFunctionExpr fe) '''
	«fe.function»(«fe.expr.compile»)
	'''
	
	def compile(EMetricExpr me) '''
	«me.type.type»{«processTagList(me.tags)»}«IF me.period !== null»[«FOR seg: me.period.segments»«seg.value»«seg.unit»«ENDFOR»]«ENDIF»
	'''
	
	def compile(EAritmeticExpr ae) '''
	(«ae.loperad.compile» «ae.oper.type» «ae.roperad.compile»)
	'''
	
	def compile(EVectorMatching vm) '''
	«vm.type»(«vm.labels.compile») «vm.expr.compile»
	'''
	
	def compile(ELabelList ll) '''
	«processLabelList(ll.list)»
	'''
	
	def compile(EAggregationExpr ae) '''
	«ae.oper» «IF ae.modifier !== null»«ae.modifier»(«ae.labels.compile»)«ENDIF»(«ae.expr.compile»)
	'''
	
	def compile(EBinaryLogicExpr ble) '''
	(«ble.first.compile» «ble.oper.type» «ble.second.compile»)
	'''
	
	def compile(Enot n) '''
	not(«n.not.compile»)
	'''
	
	def compile(ELabel l) '''
	«l.key»: «processString(l.value)»
	'''
	
	def processLabelList(EList<ESingleLabel> list){
		val StringBuffer st = new StringBuffer()
		var comma = false
		for (l: list){
			if (comma)
				st.append(", ")
			else
				comma = true
			st.append(l.label)
		}
		return st.toString
	}
	
	def processTagList(EList<ETag> list){
		val StringBuffer st = new StringBuffer()
		var comma = false
		for (t: list){
			if (comma)
				st.append(", ")
			else
				comma = true
			if (t.key.equals("monitoring_id"))
				st.append(t.key + t.oper.type + "\"" + "{{ $labels.monitoring_id }}" + "\"")
			else
				st.append(t.key + t.oper.type + "\"" + t.value + "\"")
		}
		
		if (!containsMonitoringId(list))
			if (comma)
				st.append(", ")
			st.append("monitoring_id" + "=" + "\"" + "{{ $labels.monitoring_id }}" + "\"")
		return st.toString
	}
		
	def containsMonitoringId(EList<ETag> list) {
		for (t: list){
			if (t.key.equals("monitoring_id"))
				return true
		}
		return false
	}
	
	def getFilename(URI uri) {
		var filename = uri.toString
		filename = filename.replace("platform:/resource", "")
		filename = filename.substring(
				filename.indexOf('/', 1) + 1).replaceFirst('/', ".") + ".rules";
		return filename 
	}
	
	def processString (String _string){
		return _string.replaceAll("[\\n\\r]+","\\\\n")
	}
	
	def trim (CharSequence value) {
		return value.toString.trim.replaceAll("[\n\r]", "")
	}
}
