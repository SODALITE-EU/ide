/*
 * generated by Xtext 2.22.0
 */
package org.sodalite.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.sodalite.dsl.alerting.AlertingPackage;
import org.sodalite.dsl.alerting.Alerting_Model;
import org.sodalite.dsl.alerting.EAggregationExpr;
import org.sodalite.dsl.alerting.EArithmeticOperator;
import org.sodalite.dsl.alerting.EBinaryExpr;
import org.sodalite.dsl.alerting.EBinaryLogicOperator;
import org.sodalite.dsl.alerting.EBinaryStatement;
import org.sodalite.dsl.alerting.EComparisonOperator;
import org.sodalite.dsl.alerting.EExpression;
import org.sodalite.dsl.alerting.EFunctionExpr;
import org.sodalite.dsl.alerting.EGroup;
import org.sodalite.dsl.alerting.EGroups;
import org.sodalite.dsl.alerting.ELabel;
import org.sodalite.dsl.alerting.ELabelList;
import org.sodalite.dsl.alerting.EMetricExpr;
import org.sodalite.dsl.alerting.EMetricType;
import org.sodalite.dsl.alerting.ENUMBER;
import org.sodalite.dsl.alerting.EOperAssociation;
import org.sodalite.dsl.alerting.EPeriod;
import org.sodalite.dsl.alerting.EPeriodSegment;
import org.sodalite.dsl.alerting.ERule;
import org.sodalite.dsl.alerting.ESingleLabel;
import org.sodalite.dsl.alerting.ETag;
import org.sodalite.dsl.alerting.EVectorMatching;
import org.sodalite.dsl.services.AlertingGrammarAccess;

@SuppressWarnings("all")
public class AlertingSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AlertingGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AlertingPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AlertingPackage.ALERTING_MODEL:
				sequence_Alerting_Model(context, (Alerting_Model) semanticObject); 
				return; 
			case AlertingPackage.EAGGREGATION_EXPR:
				sequence_EAggregationExpr(context, (EAggregationExpr) semanticObject); 
				return; 
			case AlertingPackage.EARITHMETIC_OPERATOR:
				sequence_EArithmeticOperator(context, (EArithmeticOperator) semanticObject); 
				return; 
			case AlertingPackage.EBINARY_EXPR:
				sequence_EBinaryExpr(context, (EBinaryExpr) semanticObject); 
				return; 
			case AlertingPackage.EBINARY_LOGIC_OPERATOR:
				sequence_EBinaryLogicOperator(context, (EBinaryLogicOperator) semanticObject); 
				return; 
			case AlertingPackage.EBINARY_STATEMENT:
				sequence_EBinaryStatement(context, (EBinaryStatement) semanticObject); 
				return; 
			case AlertingPackage.ECOMPARISON_OPERATOR:
				sequence_EComparisonOperator(context, (EComparisonOperator) semanticObject); 
				return; 
			case AlertingPackage.EEXPRESSION:
				sequence_EExpression(context, (EExpression) semanticObject); 
				return; 
			case AlertingPackage.EFUNCTION_EXPR:
				sequence_EFunctionExpr(context, (EFunctionExpr) semanticObject); 
				return; 
			case AlertingPackage.EGROUP:
				sequence_EGroup(context, (EGroup) semanticObject); 
				return; 
			case AlertingPackage.EGROUPS:
				sequence_EGroups(context, (EGroups) semanticObject); 
				return; 
			case AlertingPackage.ELABEL:
				sequence_ELabel(context, (ELabel) semanticObject); 
				return; 
			case AlertingPackage.ELABEL_LIST:
				sequence_ELabelList(context, (ELabelList) semanticObject); 
				return; 
			case AlertingPackage.EMETRIC_EXPR:
				sequence_EMetricExpr(context, (EMetricExpr) semanticObject); 
				return; 
			case AlertingPackage.EMETRIC_TYPE:
				sequence_EMetricType(context, (EMetricType) semanticObject); 
				return; 
			case AlertingPackage.ENUMBER:
				sequence_ENUMBER(context, (ENUMBER) semanticObject); 
				return; 
			case AlertingPackage.EOPER_ASSOCIATION:
				sequence_EOperAssociation(context, (EOperAssociation) semanticObject); 
				return; 
			case AlertingPackage.EPERIOD:
				sequence_EPeriod(context, (EPeriod) semanticObject); 
				return; 
			case AlertingPackage.EPERIOD_SEGMENT:
				sequence_EPeriodSegment(context, (EPeriodSegment) semanticObject); 
				return; 
			case AlertingPackage.ERULE:
				sequence_ERule(context, (ERule) semanticObject); 
				return; 
			case AlertingPackage.ESINGLE_LABEL:
				sequence_ESingleLabel(context, (ESingleLabel) semanticObject); 
				return; 
			case AlertingPackage.ETAG:
				sequence_ETag(context, (ETag) semanticObject); 
				return; 
			case AlertingPackage.EVECTOR_MATCHING:
				sequence_EVectorMatching(context, (EVectorMatching) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Alerting_Model returns Alerting_Model
	 *
	 * Constraint:
	 *     groups+=EGroups+
	 */
	protected void sequence_Alerting_Model(ISerializationContext context, Alerting_Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EStatement returns EAggregationExpr
	 *     EAggregationExpr returns EAggregationExpr
	 *     EVectorExpr returns EAggregationExpr
	 *
	 * Constraint:
	 *     (oper=EAGGREGATIONOPER (modifier=EAGGREGATIONOPERMODIFIER labels=ELabelList)? expr=EVectorExpr)
	 */
	protected void sequence_EAggregationExpr(ISerializationContext context, EAggregationExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EBinaryOperator returns EArithmeticOperator
	 *     EArithmeticOperator returns EArithmeticOperator
	 *
	 * Constraint:
	 *     (
	 *         type='+' | 
	 *         type='-' | 
	 *         type='*' | 
	 *         type='/' | 
	 *         type='%' | 
	 *         type='^'
	 *     )
	 */
	protected void sequence_EArithmeticOperator(ISerializationContext context, EArithmeticOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EStatement returns EBinaryExpr
	 *     EVectorExpr returns EBinaryExpr
	 *     EBinaryExpr returns EBinaryExpr
	 *
	 * Constraint:
	 *     (lexpr=EVectorExpr oper=EBinaryOperator rexpr=EVectorExpr)
	 */
	protected void sequence_EBinaryExpr(ISerializationContext context, EBinaryExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EBINARY_EXPR__LEXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EBINARY_EXPR__LEXPR));
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EBINARY_EXPR__OPER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EBINARY_EXPR__OPER));
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EBINARY_EXPR__REXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EBINARY_EXPR__REXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEBinaryExprAccess().getLexprEVectorExprParserRuleCall_1_0(), semanticObject.getLexpr());
		feeder.accept(grammarAccess.getEBinaryExprAccess().getOperEBinaryOperatorParserRuleCall_2_0(), semanticObject.getOper());
		feeder.accept(grammarAccess.getEBinaryExprAccess().getRexprEVectorExprParserRuleCall_3_0(), semanticObject.getRexpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EBinaryOperator returns EBinaryLogicOperator
	 *     EBinaryLogicOperator returns EBinaryLogicOperator
	 *
	 * Constraint:
	 *     (type='and' | type='or' | type='unless')
	 */
	protected void sequence_EBinaryLogicOperator(ISerializationContext context, EBinaryLogicOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EBinaryStatement returns EBinaryStatement
	 *
	 * Constraint:
	 *     (lexpr=EStatement oper=EComparisonOperator rexpr=ENUMBER)
	 */
	protected void sequence_EBinaryStatement(ISerializationContext context, EBinaryStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EBINARY_STATEMENT__LEXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EBINARY_STATEMENT__LEXPR));
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EBINARY_STATEMENT__OPER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EBINARY_STATEMENT__OPER));
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EBINARY_STATEMENT__REXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EBINARY_STATEMENT__REXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEBinaryStatementAccess().getLexprEStatementParserRuleCall_0_0(), semanticObject.getLexpr());
		feeder.accept(grammarAccess.getEBinaryStatementAccess().getOperEComparisonOperatorParserRuleCall_1_0(), semanticObject.getOper());
		feeder.accept(grammarAccess.getEBinaryStatementAccess().getRexprENUMBERParserRuleCall_2_0(), semanticObject.getRexpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EBinaryOperator returns EComparisonOperator
	 *     EComparisonOperator returns EComparisonOperator
	 *
	 * Constraint:
	 *     (type='<' | type='>' | type='<=' | type='>=' | type='==')
	 */
	protected void sequence_EComparisonOperator(ISerializationContext context, EComparisonOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EExpression returns EExpression
	 *
	 * Constraint:
	 *     expr=EBinaryStatement
	 */
	protected void sequence_EExpression(ISerializationContext context, EExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EEXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EEXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEExpressionAccess().getExprEBinaryStatementParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EStatement returns EFunctionExpr
	 *     EVectorExpr returns EFunctionExpr
	 *     EFunctionExpr returns EFunctionExpr
	 *
	 * Constraint:
	 *     (function=EFUNCTIONTYPE expr=EVectorExpr?)
	 */
	protected void sequence_EFunctionExpr(ISerializationContext context, EFunctionExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EGroup returns EGroup
	 *
	 * Constraint:
	 *     (name=ID rules+=ERule*)
	 */
	protected void sequence_EGroup(ISerializationContext context, EGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EGroups returns EGroups
	 *
	 * Constraint:
	 *     groups+=EGroup
	 */
	protected void sequence_EGroups(ISerializationContext context, EGroups semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ELabelList returns ELabelList
	 *
	 * Constraint:
	 *     (list+=ESingleLabel? list+=ESingleLabel*)
	 */
	protected void sequence_ELabelList(ISerializationContext context, ELabelList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ELabel returns ELabel
	 *
	 * Constraint:
	 *     (key=ID value=STRING)
	 */
	protected void sequence_ELabel(ISerializationContext context, ELabel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.ELABEL__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.ELABEL__KEY));
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.ELABEL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.ELABEL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getELabelAccess().getKeyIDTerminalRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getELabelAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EStatement returns EMetricExpr
	 *     EVectorExpr returns EMetricExpr
	 *     EMetricExpr returns EMetricExpr
	 *
	 * Constraint:
	 *     (type=EMetricType tags+=ETag? tags+=ETag* period=EPeriod?)
	 */
	protected void sequence_EMetricExpr(ISerializationContext context, EMetricExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EMetricType returns EMetricType
	 *
	 * Constraint:
	 *     (type=ESLURMEXPORTER | type=EPBSEXPORTER | type=ENODEEXPORTER)
	 */
	protected void sequence_EMetricType(ISerializationContext context, EMetricType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EStatement returns ENUMBER
	 *     EVectorExpr returns ENUMBER
	 *     ENUMBER returns ENUMBER
	 *
	 * Constraint:
	 *     value=NUMBER
	 */
	protected void sequence_ENUMBER(ISerializationContext context, ENUMBER semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.ENUMBER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.ENUMBER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getENUMBERAccess().getValueNUMBERParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EOperAssociation returns EOperAssociation
	 *
	 * Constraint:
	 *     (type='=' | type='=~' | type='!=' | type='~')
	 */
	protected void sequence_EOperAssociation(ISerializationContext context, EOperAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EPeriodSegment returns EPeriodSegment
	 *
	 * Constraint:
	 *     (value=INT unit=EPERIODUNIT)
	 */
	protected void sequence_EPeriodSegment(ISerializationContext context, EPeriodSegment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EPERIOD_SEGMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EPERIOD_SEGMENT__VALUE));
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EPERIOD_SEGMENT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EPERIOD_SEGMENT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEPeriodSegmentAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getEPeriodSegmentAccess().getUnitEPERIODUNITTerminalRuleCall_1_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EPeriod returns EPeriod
	 *
	 * Constraint:
	 *     (segments+=EPeriodSegment segments+=EPeriodSegment*)
	 */
	protected void sequence_EPeriod(ISerializationContext context, EPeriod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ERule returns ERule
	 *
	 * Constraint:
	 *     (alert=ID expr=EExpression duration=STRING? labels+=ELabel* annotations+=ELabel*)
	 */
	protected void sequence_ERule(ISerializationContext context, ERule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ESingleLabel returns ESingleLabel
	 *
	 * Constraint:
	 *     label=ID
	 */
	protected void sequence_ESingleLabel(ISerializationContext context, ESingleLabel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.ESINGLE_LABEL__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.ESINGLE_LABEL__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getESingleLabelAccess().getLabelIDTerminalRuleCall_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ETag returns ETag
	 *
	 * Constraint:
	 *     (key=ID oper=EOperAssociation value=STRING)
	 */
	protected void sequence_ETag(ISerializationContext context, ETag semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.ETAG__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.ETAG__KEY));
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.ETAG__OPER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.ETAG__OPER));
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.ETAG__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.ETAG__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getETagAccess().getKeyIDTerminalRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getETagAccess().getOperEOperAssociationParserRuleCall_1_0(), semanticObject.getOper());
		feeder.accept(grammarAccess.getETagAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EStatement returns EVectorMatching
	 *     EVectorMatching returns EVectorMatching
	 *
	 * Constraint:
	 *     (lexpr=EVectorExpr oper=EBinaryOperator type=EVECTORMATCHINGTYPE labels=ELabelList rexpr=EVectorExpr)
	 */
	protected void sequence_EVectorMatching(ISerializationContext context, EVectorMatching semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EVECTOR_MATCHING__LEXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EVECTOR_MATCHING__LEXPR));
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EVECTOR_MATCHING__OPER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EVECTOR_MATCHING__OPER));
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EVECTOR_MATCHING__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EVECTOR_MATCHING__TYPE));
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EVECTOR_MATCHING__LABELS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EVECTOR_MATCHING__LABELS));
			if (transientValues.isValueTransient(semanticObject, AlertingPackage.Literals.EVECTOR_MATCHING__REXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlertingPackage.Literals.EVECTOR_MATCHING__REXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEVectorMatchingAccess().getLexprEVectorExprParserRuleCall_1_0(), semanticObject.getLexpr());
		feeder.accept(grammarAccess.getEVectorMatchingAccess().getOperEBinaryOperatorParserRuleCall_2_0(), semanticObject.getOper());
		feeder.accept(grammarAccess.getEVectorMatchingAccess().getTypeEVECTORMATCHINGTYPETerminalRuleCall_3_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getEVectorMatchingAccess().getLabelsELabelListParserRuleCall_5_0(), semanticObject.getLabels());
		feeder.accept(grammarAccess.getEVectorMatchingAccess().getRexprEVectorExprParserRuleCall_7_0(), semanticObject.getRexpr());
		feeder.finish();
	}
	
	
}
