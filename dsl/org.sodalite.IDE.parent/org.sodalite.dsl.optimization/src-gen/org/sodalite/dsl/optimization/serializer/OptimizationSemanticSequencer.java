/*
 * generated by Xtext 2.19.0
 */
package org.sodalite.dsl.optimization.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.sodalite.dsl.optimization.optimization.EAITraining;
import org.sodalite.dsl.optimization.optimization.EAITrainingCase;
import org.sodalite.dsl.optimization.optimization.EAITrainingConfig;
import org.sodalite.dsl.optimization.optimization.EAITrainingData;
import org.sodalite.dsl.optimization.optimization.EAITrainingETL;
import org.sodalite.dsl.optimization.optimization.EAutotuingDSL;
import org.sodalite.dsl.optimization.optimization.EAutotuning;
import org.sodalite.dsl.optimization.optimization.EAutotuningCase;
import org.sodalite.dsl.optimization.optimization.EBuild;
import org.sodalite.dsl.optimization.optimization.EHPC;
import org.sodalite.dsl.optimization.optimization.EHPCConfig;
import org.sodalite.dsl.optimization.optimization.EHPCData;
import org.sodalite.dsl.optimization.optimization.EHPCETL;
import org.sodalite.dsl.optimization.optimization.EKeras;
import org.sodalite.dsl.optimization.optimization.EKerasCase;
import org.sodalite.dsl.optimization.optimization.EMPI;
import org.sodalite.dsl.optimization.optimization.EMPICase;
import org.sodalite.dsl.optimization.optimization.EOPENACC;
import org.sodalite.dsl.optimization.optimization.EOPENACCCase;
import org.sodalite.dsl.optimization.optimization.EOPENCL;
import org.sodalite.dsl.optimization.optimization.EOPENCLCase;
import org.sodalite.dsl.optimization.optimization.EOPENMP;
import org.sodalite.dsl.optimization.optimization.EOPENMPCase;
import org.sodalite.dsl.optimization.optimization.EOptBuild;
import org.sodalite.dsl.optimization.optimization.EOptimization;
import org.sodalite.dsl.optimization.optimization.EParameters;
import org.sodalite.dsl.optimization.optimization.EPyTorch;
import org.sodalite.dsl.optimization.optimization.EPyTorchCase;
import org.sodalite.dsl.optimization.optimization.ERun;
import org.sodalite.dsl.optimization.optimization.ETensorFlow;
import org.sodalite.dsl.optimization.optimization.ETensorFlowCase;
import org.sodalite.dsl.optimization.optimization.OptimizationPackage;
import org.sodalite.dsl.optimization.optimization.Optimization_Model;
import org.sodalite.dsl.optimization.services.OptimizationGrammarAccess;

@SuppressWarnings("all")
public class OptimizationSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OptimizationGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OptimizationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OptimizationPackage.EAI_TRAINING:
				sequence_EAITraining(context, (EAITraining) semanticObject); 
				return; 
			case OptimizationPackage.EAI_TRAINING_CASE:
				sequence_EAITrainingCase(context, (EAITrainingCase) semanticObject); 
				return; 
			case OptimizationPackage.EAI_TRAINING_CONFIG:
				sequence_EAITrainingConfig(context, (EAITrainingConfig) semanticObject); 
				return; 
			case OptimizationPackage.EAI_TRAINING_DATA:
				sequence_EAITrainingData(context, (EAITrainingData) semanticObject); 
				return; 
			case OptimizationPackage.EAI_TRAINING_ETL:
				sequence_EAITrainingETL(context, (EAITrainingETL) semanticObject); 
				return; 
			case OptimizationPackage.EAUTOTUING_DSL:
				sequence_EAutotuingDSL(context, (EAutotuingDSL) semanticObject); 
				return; 
			case OptimizationPackage.EAUTOTUNING:
				sequence_EAutotuning(context, (EAutotuning) semanticObject); 
				return; 
			case OptimizationPackage.EAUTOTUNING_CASE:
				sequence_EAutotuningCase(context, (EAutotuningCase) semanticObject); 
				return; 
			case OptimizationPackage.EBUILD:
				sequence_EBuild(context, (EBuild) semanticObject); 
				return; 
			case OptimizationPackage.EHPC:
				sequence_EHPC(context, (EHPC) semanticObject); 
				return; 
			case OptimizationPackage.EHPC_CONFIG:
				sequence_EHPCConfig(context, (EHPCConfig) semanticObject); 
				return; 
			case OptimizationPackage.EHPC_DATA:
				sequence_EHPCData(context, (EHPCData) semanticObject); 
				return; 
			case OptimizationPackage.EHPCETL:
				sequence_EHPCETL(context, (EHPCETL) semanticObject); 
				return; 
			case OptimizationPackage.EKERAS:
				sequence_EKeras(context, (EKeras) semanticObject); 
				return; 
			case OptimizationPackage.EKERAS_CASE:
				sequence_EKerasCase(context, (EKerasCase) semanticObject); 
				return; 
			case OptimizationPackage.EMPI:
				sequence_EMPI(context, (EMPI) semanticObject); 
				return; 
			case OptimizationPackage.EMPI_CASE:
				sequence_EMPICase(context, (EMPICase) semanticObject); 
				return; 
			case OptimizationPackage.EOPENACC:
				sequence_EOPENACC(context, (EOPENACC) semanticObject); 
				return; 
			case OptimizationPackage.EOPENACC_CASE:
				sequence_EOPENACCCase(context, (EOPENACCCase) semanticObject); 
				return; 
			case OptimizationPackage.EOPENCL:
				sequence_EOPENCL(context, (EOPENCL) semanticObject); 
				return; 
			case OptimizationPackage.EOPENCL_CASE:
				sequence_EOPENCLCase(context, (EOPENCLCase) semanticObject); 
				return; 
			case OptimizationPackage.EOPENMP:
				sequence_EOPENMP(context, (EOPENMP) semanticObject); 
				return; 
			case OptimizationPackage.EOPENMP_CASE:
				sequence_EOPENMPCase(context, (EOPENMPCase) semanticObject); 
				return; 
			case OptimizationPackage.EOPT_BUILD:
				sequence_EOptBuild(context, (EOptBuild) semanticObject); 
				return; 
			case OptimizationPackage.EOPTIMIZATION:
				sequence_EOptimization(context, (EOptimization) semanticObject); 
				return; 
			case OptimizationPackage.EPARAMETERS:
				sequence_EParameters(context, (EParameters) semanticObject); 
				return; 
			case OptimizationPackage.EPY_TORCH:
				sequence_EPyTorch(context, (EPyTorch) semanticObject); 
				return; 
			case OptimizationPackage.EPY_TORCH_CASE:
				sequence_EPyTorchCase(context, (EPyTorchCase) semanticObject); 
				return; 
			case OptimizationPackage.ERUN:
				sequence_ERun(context, (ERun) semanticObject); 
				return; 
			case OptimizationPackage.ETENSOR_FLOW:
				sequence_ETensorFlow(context, (ETensorFlow) semanticObject); 
				return; 
			case OptimizationPackage.ETENSOR_FLOW_CASE:
				sequence_ETensorFlowCase(context, (ETensorFlowCase) semanticObject); 
				return; 
			case OptimizationPackage.OPTIMIZATION_MODEL:
				sequence_Optimization_Model(context, (Optimization_Model) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     EOptimizationCases returns EAITrainingCase
	 *     EAITrainingCase returns EAITrainingCase
	 *
	 * Constraint:
	 *     ai_training=EAITraining
	 */
	protected void sequence_EAITrainingCase(ISerializationContext context, EAITrainingCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EAI_TRAINING_CASE__AI_TRAINING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EAI_TRAINING_CASE__AI_TRAINING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEAITrainingCaseAccess().getAi_trainingEAITrainingParserRuleCall_2_0(), semanticObject.getAi_training());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EAITrainingConfig returns EAITrainingConfig
	 *
	 * Constraint:
	 *     (ai_framework=EAIFramework | type=EAITrainingType | distributed_training=BOOLEAN | layers=INT | parameters=INT)+
	 */
	protected void sequence_EAITrainingConfig(ISerializationContext context, EAITrainingConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAITrainingData returns EAITrainingData
	 *
	 * Constraint:
	 *     (location=STRING | basedata=EBasedata | size=INT | count=INT | etl=EAITrainingETL)+
	 */
	protected void sequence_EAITrainingData(ISerializationContext context, EAITrainingData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAITrainingETL returns EAITrainingETL
	 *
	 * Constraint:
	 *     (prefetch=INT | cache=INT)+
	 */
	protected void sequence_EAITrainingETL(ISerializationContext context, EAITrainingETL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAITraining returns EAITraining
	 *
	 * Constraint:
	 *     (config=EAITrainingConfig data=EAITrainingData aitrainingcase=EAITrainingCases)
	 */
	protected void sequence_EAITraining(ISerializationContext context, EAITraining semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EAI_TRAINING__CONFIG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EAI_TRAINING__CONFIG));
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EAI_TRAINING__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EAI_TRAINING__DATA));
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EAI_TRAINING__AITRAININGCASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EAI_TRAINING__AITRAININGCASE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEAITrainingAccess().getConfigEAITrainingConfigParserRuleCall_0_2_0(), semanticObject.getConfig());
		feeder.accept(grammarAccess.getEAITrainingAccess().getDataEAITrainingDataParserRuleCall_1_2_0(), semanticObject.getData());
		feeder.accept(grammarAccess.getEAITrainingAccess().getAitrainingcaseEAITrainingCasesParserRuleCall_2_0(), semanticObject.getAitrainingcase());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EAutotuingDSL returns EAutotuingDSL
	 *
	 * Constraint:
	 *     (parameters=EParameters parameters=EBuild parameters=ERun)
	 */
	protected void sequence_EAutotuingDSL(ISerializationContext context, EAutotuingDSL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EOptimizationCases returns EAutotuningCase
	 *     EAutotuningCase returns EAutotuningCase
	 *
	 * Constraint:
	 *     hpc=EHPC
	 */
	protected void sequence_EAutotuningCase(ISerializationContext context, EAutotuningCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EAUTOTUNING_CASE__HPC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EAUTOTUNING_CASE__HPC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEAutotuningCaseAccess().getHpcEHPCParserRuleCall_2_0(), semanticObject.getHpc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EAutotuning returns EAutotuning
	 *
	 * Constraint:
	 *     (tuner=ETuner | input=EAutotuingDSL)+
	 */
	protected void sequence_EAutotuning(ISerializationContext context, EAutotuning semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EBuild returns EBuild
	 *
	 * Constraint:
	 *     command=STRING
	 */
	protected void sequence_EBuild(ISerializationContext context, EBuild semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EBUILD__COMMAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EBUILD__COMMAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEBuildAccess().getCommandSTRINGTerminalRuleCall_1_0(), semanticObject.getCommand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EHPCConfig returns EHPCConfig
	 *
	 * Constraint:
	 *     ai_framework=EParallelisation
	 */
	protected void sequence_EHPCConfig(ISerializationContext context, EHPCConfig semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EHPC_CONFIG__AI_FRAMEWORK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EHPC_CONFIG__AI_FRAMEWORK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEHPCConfigAccess().getAi_frameworkEParallelisationParserRuleCall_1_0(), semanticObject.getAi_framework());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EHPCData returns EHPCData
	 *
	 * Constraint:
	 *     (location=STRING | basedata=EHPCBasedata | size=INT | count=INT | etl=EHPCETL)+
	 */
	protected void sequence_EHPCData(ISerializationContext context, EHPCData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EHPCETL returns EHPCETL
	 *
	 * Constraint:
	 *     (prefetch=BOOLEAN | cache=BOOLEAN)+
	 */
	protected void sequence_EHPCETL(ISerializationContext context, EHPCETL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EHPC returns EHPC
	 *
	 * Constraint:
	 *     (config=EHPCConfig data=EHPCData hpccase=EHPCCases)
	 */
	protected void sequence_EHPC(ISerializationContext context, EHPC semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EHPC__CONFIG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EHPC__CONFIG));
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EHPC__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EHPC__DATA));
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EHPC__HPCCASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EHPC__HPCCASE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEHPCAccess().getConfigEHPCConfigParserRuleCall_0_2_0(), semanticObject.getConfig());
		feeder.accept(grammarAccess.getEHPCAccess().getDataEHPCDataParserRuleCall_1_2_0(), semanticObject.getData());
		feeder.accept(grammarAccess.getEHPCAccess().getHpccaseEHPCCasesParserRuleCall_2_0(), semanticObject.getHpccase());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EAITrainingCases returns EKerasCase
	 *     EKerasCase returns EKerasCase
	 *
	 * Constraint:
	 *     keras=EKeras
	 */
	protected void sequence_EKerasCase(ISerializationContext context, EKerasCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EKERAS_CASE__KERAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EKERAS_CASE__KERAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEKerasCaseAccess().getKerasEKerasParserRuleCall_2_0(), semanticObject.getKeras());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EKeras returns EKeras
	 *
	 * Constraint:
	 *     (version=STRING | backend=EBackend)+
	 */
	protected void sequence_EKeras(ISerializationContext context, EKeras semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EHPCCases returns EMPICase
	 *     EMPICase returns EMPICase
	 *
	 * Constraint:
	 *     mpi=EMPI
	 */
	protected void sequence_EMPICase(ISerializationContext context, EMPICase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EMPI_CASE__MPI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EMPI_CASE__MPI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEMPICaseAccess().getMpiEMPIParserRuleCall_2_0(), semanticObject.getMpi());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EMPI returns EMPI
	 *
	 * Constraint:
	 *     (library=EMPILibrary | version=STRING | scaling_efficiency=RealValue | core_subscription=INT | message_size=EMPIMessageSize)+
	 */
	protected void sequence_EMPI(ISerializationContext context, EMPI semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EHPCCases returns EOPENACCCase
	 *     EOPENACCCase returns EOPENACCCase
	 *
	 * Constraint:
	 *     openacc=EOPENACC
	 */
	protected void sequence_EOPENACCCase(ISerializationContext context, EOPENACCCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EOPENACC_CASE__OPENACC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EOPENACC_CASE__OPENACC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEOPENACCCaseAccess().getOpenaccEOPENACCParserRuleCall_2_0(), semanticObject.getOpenacc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EOPENACC returns EOPENACC
	 *
	 * Constraint:
	 *     (compiler=ECompiler | version=STRING | number_of_acc=INT)+
	 */
	protected void sequence_EOPENACC(ISerializationContext context, EOPENACC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EHPCCases returns EOPENCLCase
	 *     EOPENCLCase returns EOPENCLCase
	 *
	 * Constraint:
	 *     opencl=EOPENCL
	 */
	protected void sequence_EOPENCLCase(ISerializationContext context, EOPENCLCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EOPENCL_CASE__OPENCL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EOPENCL_CASE__OPENCL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEOPENCLCaseAccess().getOpenclEOPENCLParserRuleCall_2_0(), semanticObject.getOpencl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EOPENCL returns EOPENCL
	 *
	 * Constraint:
	 *     (compiler=ECompiler | version=STRING | number_of_acc=INT)+
	 */
	protected void sequence_EOPENCL(ISerializationContext context, EOPENCL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EHPCCases returns EOPENMPCase
	 *     EOPENMPCase returns EOPENMPCase
	 *
	 * Constraint:
	 *     openmp=EOPENMP
	 */
	protected void sequence_EOPENMPCase(ISerializationContext context, EOPENMPCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EOPENMP_CASE__OPENMP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EOPENMP_CASE__OPENMP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEOPENMPCaseAccess().getOpenmpEOPENMPParserRuleCall_2_0(), semanticObject.getOpenmp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EOPENMP returns EOPENMP
	 *
	 * Constraint:
	 *     (number_of_threads=INT | scaling_efficiency=RealValue | affinity=EOPENAffinity)+
	 */
	protected void sequence_EOPENMP(ISerializationContext context, EOPENMP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EOptBuild returns EOptBuild
	 *
	 * Constraint:
	 *     (cpu_type=ECPUType | acc_type=EACCType)+
	 */
	protected void sequence_EOptBuild(ISerializationContext context, EOptBuild semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EOptimization returns EOptimization
	 *
	 * Constraint:
	 *     (
	 *         enable_opt_build=BOOLEAN 
	 *         enable_autotuning=BOOLEAN 
	 *         app_type=EAppType 
	 *         opt_build=EOptBuild? 
	 *         autotuning=EAutotuning? 
	 *         app_optimization=EOptimizationCases
	 *     )
	 */
	protected void sequence_EOptimization(ISerializationContext context, EOptimization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EParameters returns EParameters
	 *
	 * Constraint:
	 *     (int=STRING range=STRING)
	 */
	protected void sequence_EParameters(ISerializationContext context, EParameters semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EPARAMETERS__INT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EPARAMETERS__INT));
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EPARAMETERS__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EPARAMETERS__RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEParametersAccess().getIntSTRINGTerminalRuleCall_0_3_0(), semanticObject.getInt());
		feeder.accept(grammarAccess.getEParametersAccess().getRangeSTRINGTerminalRuleCall_1_3_0(), semanticObject.getRange());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EAITrainingCases returns EPyTorchCase
	 *     EPyTorchCase returns EPyTorchCase
	 *
	 * Constraint:
	 *     pytorch=EPyTorch
	 */
	protected void sequence_EPyTorchCase(ISerializationContext context, EPyTorchCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.EPY_TORCH_CASE__PYTORCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.EPY_TORCH_CASE__PYTORCH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEPyTorchCaseAccess().getPytorchEPyTorchParserRuleCall_2_0(), semanticObject.getPytorch());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EPyTorch returns EPyTorch
	 *
	 * Constraint:
	 *     (version=STRING | glow=BOOLEAN)+
	 */
	protected void sequence_EPyTorch(ISerializationContext context, EPyTorch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ERun returns ERun
	 *
	 * Constraint:
	 *     command=STRING
	 */
	protected void sequence_ERun(ISerializationContext context, ERun semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.ERUN__COMMAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.ERUN__COMMAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getERunAccess().getCommandSTRINGTerminalRuleCall_1_0(), semanticObject.getCommand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EAITrainingCases returns ETensorFlowCase
	 *     ETensorFlowCase returns ETensorFlowCase
	 *
	 * Constraint:
	 *     tensorflow=ETensorFlow
	 */
	protected void sequence_ETensorFlowCase(ISerializationContext context, ETensorFlowCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.ETENSOR_FLOW_CASE__TENSORFLOW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.ETENSOR_FLOW_CASE__TENSORFLOW));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getETensorFlowCaseAccess().getTensorflowETensorFlowParserRuleCall_2_0(), semanticObject.getTensorflow());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ETensorFlow returns ETensorFlow
	 *
	 * Constraint:
	 *     (version=STRING | xla=BOOLEAN)+
	 */
	protected void sequence_ETensorFlow(ISerializationContext context, ETensorFlow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Optimization_Model returns Optimization_Model
	 *
	 * Constraint:
	 *     optimization=EOptimization
	 */
	protected void sequence_Optimization_Model(ISerializationContext context, Optimization_Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptimizationPackage.Literals.OPTIMIZATION_MODEL__OPTIMIZATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptimizationPackage.Literals.OPTIMIZATION_MODEL__OPTIMIZATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptimization_ModelAccess().getOptimizationEOptimizationParserRuleCall_2_0(), semanticObject.getOptimization());
		feeder.finish();
	}
	
	
}
